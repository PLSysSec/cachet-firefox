// vim: set tw=99 ts=4 sts=4 sw=4 et:

import "./JS.cachet"

struct Reg;

// #[cfg(cpp)]
struct ValueReg;
// #[cfg(verify)]
// type ValueReg = Reg;

impl ValueReg {
    fn scratchReg(valueReg: ValueReg) -> Reg;
}

enum Condition {
    Equal,
    NotEqual,
    Overflow,
    Zero,
    NonZero,
    Signed,
    NotSigned,
    GreaterThan,
    LessThan,
}

struct Address;

impl Address {
    fn new(base: Reg, offset: Int32) -> Address {
        let address = (unsafe { Address::newUnchecked(base, offset) } );
        assume Address::base(address) == base;
        assume Address::offset(address) == offset;
        address
    }

    unsafe fn newUnchecked(base: Reg, offset: Int32) -> Address;

    fn base(address: Address) -> Reg;
    fn offset(address: Address) -> Int32;
}

ir MASM {
    op Mov(srcReg: Reg, dstReg: Reg) {
        MASM::setInt32(dstReg, MASM::getInt32(srcReg));
    }

    op Move32Imm32(srcInt32: Int32, dstReg: Reg) {
        MASM::setInt32(dstReg, srcInt32);
    }

    op Cmp32Move32(condition: Condition, lhsReg: Reg, rhsReg: Reg, srcReg: Reg, dstReg: Reg) {
        assert (condition == Condition::GreaterThan || condition == Condition::LessThan);

        let lhsInt32 = MASM::getInt32(lhsReg);
        let rhsInt32 = MASM::getInt32(rhsReg);
        let srcInt32 = MASM::getInt32(srcReg);

        if condition == Condition::GreaterThan && lhsInt32 > rhsInt32 {
            MASM::setInt32(dstReg, srcInt32);
        } else if condition == Condition::LessThan && lhsInt32 < rhsInt32 {
            MASM::setInt32(dstReg, srcInt32);
        }
    }

    op MoveBool(srcReg: Reg, dstReg: Reg) {
        MASM::setBool(dstReg, MASM::getBool(srcReg));
    }

    op Jump(label target: MASM) {
      goto target;
    }

    op LoadValueAddress(address: Address, dstReg: ValueReg) {
        let baseData = MASM::getData(Address::base(address));
        let data = RegData::readData(baseData, Address::offset(address));
        let value = RegData::toValue(data);
        MASM::setValue(dstReg, value);
    }

    op UnboxObject(valueReg: ValueReg, objectReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setObject(objectReg, Value::toObject(value));
    }

    op FallibleUnboxBoolean(valueReg: ValueReg, boolReg: Reg, label failure: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsBool = Value::isBool(value);

        if !valueIsBool {
            goto failure;
        }

        let bool = Value::toBool(value);
        MASM::setBool(boolReg, bool);
    }

    op UnboxInt32(valueReg: ValueReg, int32Reg: Reg) {
      let value = MASM::getValue(valueReg);
      MASM::setInt32(int32Reg, Value::toInt32(value)); 
    }

    op UnboxNonDouble(valueReg: ValueReg, dstReg: Reg, valTy: JSValueType) {
        assert valTy != JSValueType::Double;

        let value = MASM::getValue(valueReg);

        if valTy == JSValueType::Int32 {
            let i = Value::toInt32(value);
            MASM::setInt32(dstReg, i);
        } else if valTy == JSValueType::Bool {
            let b = Value::toBool(value);
            MASM::setBool(dstReg, b);
        } else if valTy == JSValueType::String {
            let s = Value::toString(value);
            MASM::setString(dstReg, s);
        } else if valTy == JSValueType::Symbol {
            let s = Value::toSymbol(value);
            MASM::setSymbol(dstReg, s);
        } else if valTy == JSValueType::BigInt {
            let b = Value::toBigInt(value);
            MASM::setBigInt(dstReg, b);
        }

        assert false;
    }

    // NOTE: This Op needs to be implemented as a Phantom Op on the
    // C++ side since Firefox implicitly reinterprets booleans
    // as int32 within registers.
    op CastBoolToInt32(int32Reg: Reg) {
        let bool = MASM::getBool(int32Reg);
        if bool {
            MASM::setInt32(int32Reg, 1_i32);
        } else {
            MASM::setInt32(int32Reg, 0_i32);
        }
    }

    op BranchTestNumber(
        condition: Condition,
        valueReg: ValueReg,
        label branch: MASM,
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);

        let valueIsNumber = Value::isInt32(value) || Value::isDouble(value);

        if condition == Condition::Equal && valueIsNumber {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsNumber {
            goto branch;
        }
    }

    op BranchTestNumberTag(
        condition: Condition,
        tagReg: Reg,
        label branch: MASM,
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let tag = MASM::getValueTag(tagReg);

        let valueIsNumber = tag == ValueType::Int32 || tag == ValueType::Double;

        if condition == Condition::Equal && valueIsNumber {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsNumber {
            goto branch;
        }
    }

    op BranchTestBoolean(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsBool = Value::isBool(value);

        if condition == Condition::Equal && valueIsBool {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsBool {
            goto branch;
        }
    }

    op BranchTestString(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsString = Value::isString(value);

        if condition == Condition::Equal && valueIsString {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsString {
            goto branch;
        }
    }

    op BranchTestSymbol(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsSymbol = Value::isSymbol(value);

        if condition == Condition::Equal && valueIsSymbol {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsSymbol {
            goto branch;
        }
    }

    op BranchTestBigInt(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsBigInt = Value::isBigInt(value);

        if condition == Condition::Equal && valueIsBigInt {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsBigInt {
            goto branch;
        }
    }

    op BranchTestNull(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let value = MASM::getValue(valueReg);
        let valueIsNull = Value::isNull(value);

        if condition == Condition::Equal {
            if valueIsNull {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsNull {
                goto branch;
            }
        }
    }

    op BranchTestObject(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsObject = Value::isObject(value);

        if condition == Condition::Equal {
            if valueIsObject {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsObject {
                goto branch;
            }
        }
    }

    op BranchTestObjClass(
        condition: Condition, objectReg: Reg, class: Class, scratchReg: Reg, spectreRegToZero: Reg,
        label branch: MASM
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        assert scratchReg != spectreRegToZero;

        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        MASM::setData(scratchReg, RegData::fromClass(class));

        let objectHasClass = Shape::classOf(shape) == class;

        if condition == Condition::Equal && objectHasClass {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasClass {
            goto branch;
        }

        MASM::setInt32(scratchReg, 0_i32);
    }

    op BranchTestObjClassNoSpectreMitigations(
        condition: Condition, objectReg: Reg, class: Class, scratchReg: Reg, label branch: MASM
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        MASM::setData(scratchReg, RegData::fromClass(class));

        let objectHasClass = Shape::classOf(shape) == class;

        if condition == Condition::Equal && objectHasClass {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasClass {
            goto branch;
        }
    }

    op BranchTestObjectShape(
        condition: Condition, objectReg: Reg, shape: Shape, scratchReg: Reg, spectreRegToZero: Reg,
        label branch: MASM
    ) {
        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        MASM::setInt32(scratchReg, 0_i32);

        if condition == Condition::Equal && objectHasShape {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasShape {
            goto branch;
        }
    }

    op BranchTestObjectShapeNoSpectreMitigations(
        condition: Condition, objectReg: Reg, shape: Shape, label branch: MASM
    ) {
        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        if condition == Condition::Equal && objectHasShape {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasShape {
            goto branch;
        }
    }

    op BranchTestUndefined(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let value = MASM::getValue(valueReg);
        let valueIsUndefined = Value::isUndefined(value);

        if condition == Condition::Equal && valueIsUndefined{
            goto branch;
        }

        if condition == Condition::NotEqual && !valueIsUndefined {
            goto branch;
        }
    }

    op BranchTestInt32(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsInt32 = Value::isInt32(value);

        if condition == Condition::Equal {
            if valueIsInt32 {
                goto branch;
            }
        } else if condition == Condition::NotEqual {
            if !valueIsInt32 {
                goto branch;
            }
        } else {
            assert false;
        }
    }

    op BranchTest32(condition: Condition, lhsReg: Reg, rhsReg: Reg, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(lhsReg);
      let rhsInt32 = MASM::getInt32(rhsReg);

      let result = lhsInt32 & rhsInt32;

      assert (
        condition == Condition::Zero ||
        condition == Condition::NonZero ||
        condition == Condition::Signed ||
        condition == Condition::NotSigned
      );

      if condition == Condition::Zero {
        if result == 0_i32 {
          goto branch;
        }
      } else if condition == Condition::NonZero {
        if result != 0_i32 {
          goto branch;
        }
      } else if condition == Condition::Signed {
        if result < 0_i32 {
          goto branch;
        }
      } else if condition == Condition::NotSigned {
        if result > 0_i32 {
          goto branch;
        }
      }
    }

    op BranchTest32Imm(condition: Condition, lhsReg: Reg, rhsInt32: Int32, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(lhsReg);

      let result = lhsInt32 & rhsInt32;

      assert (
        condition == Condition::Zero ||
        condition == Condition::NonZero ||
        condition == Condition::Signed ||
        condition == Condition::NotSigned
      );

      if condition == Condition::Zero {
        if result == 0_i32 {
          goto branch;
        }
      } else if condition == Condition::NonZero {
        if result != 0_i32 {
          goto branch;
        }
      } else if condition == Condition::Signed {
        if result < 0_i32 {
          goto branch;
        }
      } else if condition == Condition::NotSigned {
        if result > 0_i32 {
          goto branch;
        }
      }
    }

    op Branch32Tag(condition: Condition, lhsReg: Reg, rhsReg: Reg, label branch: MASM) {
        assert (
            condition == Condition::Equal || condition == Condition::NotEqual
        );

        let lhsTag = MASM::getValueTag(lhsReg);
        let rhsTag = MASM::getValueTag(rhsReg);

        if condition == Condition::Equal && lhsTag == rhsTag {
            goto branch;
        } else if condition == Condition::NotEqual && lhsTag != rhsTag {
            goto branch;
        }
    }

    // NOTE: This Op needs to be implemented on the C++ to delegate to the
    // appropriate overload of Branch32Imm since Cachet doesn't have overloading.
    op Branch32Imm(condition: Condition, lhsReg: Reg, rhsInt32: Int32, label branch: MASM) {
        assert (
            condition == Condition::Equal ||
            condition == Condition::NotEqual ||
            condition == Condition::LessThan
        );

        let lhsInt32 = MASM::getInt32(lhsReg);

        if condition == Condition::Equal && lhsInt32 == rhsInt32 {
            goto branch;
        } else if condition == Condition::NotEqual && lhsInt32 != rhsInt32 {
            goto branch;
        } else if condition == Condition::LessThan && lhsInt32 < rhsInt32 {
            goto branch;
        }
    }

    op BranchIfNonNativeObj(objectReg: Reg, scratchReg: Reg, label branch: MASM) {
        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        MASM::setData(scratchReg, RegData::fromClass(class));
        let objectIsNative = Class::isNativeObject(class);

        if !objectIsNative {
            goto branch;
        }
    }

    op BranchTestObjectIsProxy(proxy: Bool, objectReg: Reg, scratchReg: Reg, label branch: MASM) {
        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        MASM::setData(scratchReg, RegData::fromClass(class));
        let objectIsProxy = Class::isProxyObject(class);

        if !proxy && !objectIsProxy {
            goto branch;
        } else if proxy && objectIsProxy {
            goto branch;
        }
    }

    op TagValue(valTy: JSValueType, payload: Reg, dest: ValueReg) {
        // TODO: Don't have getters/setters for other types yet
        if valTy == JSValueType::Int32 {
            let i = MASM::getInt32(payload);
            let val = Value::fromInt32(i);
            MASM::setValue(dest, val);
        } else if valTy == JSValueType::Bool {
            let b = MASM::getBool(payload);
            let val = Value::fromBool(b);
            MASM::setValue(dest, val);
        } else if valTy == JSValueType::String {
            let s = MASM::getString(payload);
            let val = Value::fromString(s);
            MASM::setValue(dest, val);
        } else if valTy == JSValueType::Symbol {
            let s = MASM::getSymbol(payload);
            let val = Value::fromSymbol(s);
            MASM::setValue(dest, val);
        } else if valTy == JSValueType::BigInt {
            let b = MASM::getBigInt(payload);
            let val = Value::fromBigInt(b);
            MASM::setValue(dest, val);
        }

        assert false;
    }

    op BranchAdd32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
        let lhsInt32 = MASM::getInt32(srcReg);
        let rhsInt32 = MASM::getInt32(dstReg);

        let result = lhsInt32 + rhsInt32;

        assert condition == Condition::Overflow;
        if lhsInt32 > 0_i32 && rhsInt32 > 0_i32 && result < 0_i32 {
            goto branch;
        }

        if lhsInt32 < 0_i32 && rhsInt32 < 0_i32 && result > 0_i32 {
            goto branch;
        }

        MASM::setInt32(dstReg, result);
    }

    // this op corresponds to an overload of the BranchAdd32 MASM op.
    op BranchAdd32Imm(condition: Condition, lhsInt32: Int32, dstReg: Reg, label branch: MASM) {
      let rhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 + rhsInt32;

      assert condition == Condition::Overflow;
      if lhsInt32 > 0_i32 && rhsInt32 > 0_i32 && result < 0_i32 {
          goto branch;
      }

      if lhsInt32 < 0_i32 && rhsInt32 < 0_i32 && result > 0_i32 {
          goto branch;
      }

      MASM::setInt32(dstReg, result);
    }

    op BranchSub32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(dstReg);
      let rhsInt32 = MASM::getInt32(srcReg);

      let result = lhsInt32 - rhsInt32;

      assert condition == Condition::Overflow;

      let rhsInt32Neg = -rhsInt32;
      let minInt32 = 1_i32 << 31_i32; // Do it this way until negative literals are a thing

      if rhsInt32 == minInt32 && lhsInt32 >= 0_i32 {
          goto branch;
      } else if lhsInt32 > 0_i32 && rhsInt32 < 0_i32 && result < 0_i32 {
          goto branch;
      }

      if lhsInt32 < 0_i32 && rhsInt32 > 0_i32 && result > 0_i32 {
          goto branch;
      }

      MASM::setInt32(dstReg, result);
    }

    // this op corresponds to an overload of the BranchAdd32 MASM op.
    op BranchSub32Imm(condition: Condition, rhsInt32: Int32, dstReg: Reg, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 - rhsInt32;

      assert condition == Condition::Overflow;

      let rhsInt32Neg = -rhsInt32;
      let minInt32 = 1_i32 << 31_i32; // Do it this way until negative literals are a thing

      if rhsInt32 == minInt32 && lhsInt32 >= 0_i32 {
          goto branch;
      } else if lhsInt32 > 0_i32 && rhsInt32 < 0_i32 && result < 0_i32 {
          goto branch;
      }

      if lhsInt32 < 0_i32 && rhsInt32 > 0_i32 && result > 0_i32 {
          goto branch;
      }

      MASM::setInt32(dstReg, result);
    }

    op BranchMul32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
      let lhsInt32 = MASM::getInt32(dstReg);
      let rhsInt32 = MASM::getInt32(srcReg);

      let result = lhsInt32 * rhsInt32;

      assert condition == Condition::Overflow;

      let resultWide = (lhsInt32 as Int64) * (rhsInt32 as Int64);
      if (result as Int64) != resultWide {
        goto branch;
      }

      MASM::setInt32(dstReg, result);
    }

    op Neg32(valueReg: Reg) {
      let valueInt32 = MASM::getInt32(valueReg);
      let result = -valueInt32;

      MASM::setInt32(valueReg, result);
    }

    op Or32(srcReg: Reg, dstReg: Reg) {
      let lhsInt32 = MASM::getInt32(srcReg);
      let rhsInt32 = MASM::getInt32(dstReg);

      let result = lhsInt32 | rhsInt32;

      MASM::setInt32(dstReg, result);
    }

    #[spec]
    fn getData(reg: Reg) -> RegData;
    #[spec]
    fn setData(reg: Reg, data: RegData);

    #[spec]
    fn getValueTag(reg: Reg) -> ValueType {
        RegData::toValueType(MASM::getData(reg))
    }

    #[spec]
    fn setValueTag(reg:Reg, tag: ValueType) {
        MASM::setData(reg, RegData::fromValueType(tag));
    }

    fn getValue(valueReg: ValueReg) -> Value;
    fn setValue(valueReg: ValueReg, value: Value);

    fn getInt32(reg: Reg) -> Int32;
    fn setInt32(reg: Reg, int32: Int32);

    fn getObject(reg: Reg) -> Object;
    fn setObject(reg: Reg, object: Object);

    fn getBool(reg: Reg) -> Bool;
    fn setBool(reg: Reg, bool: Bool);

    fn getString(reg: Reg) -> String;
    fn setString(reg: Reg, string: String);

    fn getSymbol(reg: Reg) -> Symbol;
    fn setSymbol(reg: Reg, symbol: Symbol);

    fn getBigInt(reg: Reg) -> BigInt;
    fn setBigInt(reg: Reg, bigInt: BigInt);
}

