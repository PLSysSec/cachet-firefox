// vim: set tw=99 ts=4 sts=4 sw=4 et:

import "./JS.cachet"

enum Reg {
    Rax,
    Rcx,
    Rdx,
    Rbx,
    Rsp,
    Rbp,
    Rsi,
    Rdi,
    R8,
    R9,
    R10,
    R11,
    R12,
    R13,
    R14,
    R15,
}

impl Reg {
    fn scratchReg() -> Reg {
        Reg::R11
    }
}

// #[cfg(cpp)]
struct ValueReg;
// #[cfg(verify)]
// type ValueReg = Reg;

impl ValueReg {
    fn scratchReg(valueReg: ValueReg) -> Reg;
}

enum PhyFloatReg {
    Xmm0,
    Xmm1,
    Xmm2,
    Xmm3,
    Xmm4,
    Xmm5,
    Xmm6,
    Xmm7,
    Xmm8,
    Xmm9,
    Xmm10,
    Xmm11,
    Xmm12,
    Xmm13,
    Xmm14,
    Xmm15,
}

enum FloatContentType {
    Single,
    Double,
    Simd128,
}

struct FloatReg;

impl FloatReg {
    fn reg(floatReg: FloatReg) -> PhyFloatReg;
    fn type(floatReg: FloatReg) -> FloatContentType;

    fn new(reg: PhyFloatReg, type: FloatContentType) -> FloatReg {
        let floatReg = (unsafe { FloatReg::newUnchecked(reg, type) });
        assume FloatReg::reg(floatReg) == reg;
        assume FloatReg::type(floatReg) == type;
        floatReg
    }

    fn newDouble(reg: PhyFloatReg) -> FloatReg {
        FloatReg::new(reg, FloatContentType::Double)
    }

    unsafe fn newUnchecked(reg: PhyFloatReg, type: FloatContentType) -> FloatReg;

    fn floatReg0() -> FloatReg {
        FloatReg::newDouble(PhyFloatReg::Xmm0)
    }

    fn doubleScratchReg() -> FloatReg {
        FloatReg::newDouble((PhyFloatReg::Xmm15))
    }
}

struct AnyReg;

impl AnyReg {
    fn isFloat(anyReg: AnyReg) -> Bool;

    fn fromReg(reg: Reg) -> AnyReg {
       let anyReg = (unsafe { AnyReg::fromRegUnchecked(reg) });
       assume !AnyReg::isFloat(anyReg);
       assume (unsafe { AnyReg::toRegUnchecked(anyReg) }) == reg;
       anyReg
    }

    unsafe fn fromRegUnchecked(reg: Reg) -> AnyReg;

    fn toReg(anyReg: AnyReg) -> Reg {
        assert !AnyReg::isFloat(anyReg);
        let reg = (unsafe { AnyReg::toRegUnchecked(anyReg) });
        assume (unsafe { AnyReg::fromRegUnchecked(reg) }) == anyReg;
        reg
    }

    unsafe fn toRegUnchecked(anyReg: AnyReg) -> Reg;

    fn fromFloatReg(floatReg: FloatReg) -> AnyReg {
        let anyReg = (unsafe { AnyReg::fromFloatRegUnchecked(floatReg) });
        assume AnyReg::isFloat(anyReg);
        assume (unsafe { AnyReg::toFloatRegUnchecked(anyReg) }) == floatReg;
        anyReg
    }

    unsafe fn fromFloatRegUnchecked(floatReg: FloatReg) -> AnyReg;

    fn toFloatReg(anyReg: AnyReg) -> FloatReg {
        assert AnyReg::isFloat(anyReg);
        let floatReg = (unsafe { AnyReg::toFloatRegUnchecked(anyReg) });
        assume (unsafe { AnyReg::fromFloatRegUnchecked(floatReg) }) == anyReg;
        floatReg
    }

    unsafe fn toFloatRegUnchecked(anyReg: AnyReg) -> FloatReg;
}

struct TypedOrValueReg;

impl TypedOrValueReg {
    fn type(reg: TypedOrValueReg) -> MIRType;

    fn hasTyped(reg: TypedOrValueReg) -> Bool {
        let type = TypedOrValueReg::type(reg);
        type != MIRType::Value && type != MIRType::None
    }

    fn hasValue(reg: TypedOrValueReg) -> Bool {
        TypedOrValueReg::type(reg) == MIRType::Value
    }

    fn fromValueReg(valueReg: ValueReg) -> TypedOrValueReg {
        let reg = (unsafe { TypedOrValueReg::fromValueRegUnchecked(valueReg) });
        assume TypedOrValueReg::type(reg) == MIRType::Value;
        assume (unsafe { TypedOrValueReg::toValueRegUnchecked(reg) }) == valueReg;
        reg
    }

    unsafe fn fromValueRegUnchecked(valueReg: ValueReg) -> TypedOrValueReg;

    fn toValueReg(reg: TypedOrValueReg) -> ValueReg {
        assert TypedOrValueReg::hasValue(reg);
        let valueReg = (unsafe { TypedOrValueReg::toValueRegUnchecked(reg) });
        assume (unsafe { TypedOrValueReg::fromValueRegUnchecked(valueReg) }) == reg;
        valueReg
    }

    unsafe fn toValueRegUnchecked(reg: TypedOrValueReg) -> ValueReg;

    fn fromTypedReg(type: MIRType, typedReg: AnyReg) -> TypedOrValueReg {
        // NOTE: don't support this currently even though it may be okay
        assert type != MIRType::Value;

        let reg = (unsafe { TypedOrValueReg::fromTypedRegUnchecked(type, typedReg) });
        assume TypedOrValueReg::type(reg) == type;
        assume (unsafe { TypedOrValueReg::toTypedRegUnchecked(reg) }) == typedReg;
        reg
    }

    unsafe fn fromTypedRegUnchecked(type: MIRType, reg: AnyReg) -> TypedOrValueReg;

    fn toTypedReg(reg: TypedOrValueReg) -> AnyReg {
       assert TypedOrValueReg::hasTyped(reg);
       let typedReg = (unsafe { TypedOrValueReg::toTypedRegUnchecked(reg) });
       let type = TypedOrValueReg::type(reg);
       assume (unsafe { TypedOrValueReg::fromTypedRegUnchecked(type, typedReg) }) == reg;
       typedReg
    }

    unsafe fn toTypedRegUnchecked(reg: TypedOrValueReg) -> AnyReg;
}

struct GeneralRegSet;

impl GeneralRegSet {
    fn newEmpty() -> GeneralRegSet;
    fn newVolatile() -> GeneralRegSet;

    fn newIntersect(lhs: GeneralRegSet, rhs: GeneralRegSet) -> GeneralRegSet;
    fn newDifference(lhs: GeneralRegSet, rhs: GeneralRegSet) -> GeneralRegSet;

    #[refined]
    fn isEmpty(set: GeneralRegSet) -> Bool {
        let mut res = true;

        for reg in Reg asc {
            if GeneralRegSet::contains(set, reg) {
                res = false;
            }
        }

        res
    }

    fn contains(set: GeneralRegSet, reg: Reg) -> Bool;
    fn add(out newSet: GeneralRegSet, set: GeneralRegSet, reg: Reg);
    fn take(out newSet: GeneralRegSet, set: GeneralRegSet, reg: Reg);
}

struct FloatRegSet;

impl FloatRegSet {
    fn newEmpty() -> FloatRegSet;
    fn newVolatile() -> FloatRegSet;

    fn newIntersect(lhs: FloatRegSet, rhs: FloatRegSet) -> FloatRegSet;
    fn newDifference(lhs: FloatRegSet, rhs: FloatRegSet) -> FloatRegSet;

    fn contains(set: FloatRegSet, floatReg: FloatReg) -> Bool;
    fn add(out newSet: FloatRegSet, set: FloatRegSet, floatReg: FloatReg);
    fn take(out newSet: FloatRegSet, set: FloatRegSet, floatReg: FloatReg);

    #[refined]
    fn isEmpty(set: FloatRegSet) -> Bool {
        let mut res = true;
        for phyReg in PhyFloatReg asc {
            let singleReg = FloatReg::new(phyReg, FloatContentType::Single);
            let doubleReg = FloatReg::new(phyReg, FloatContentType::Double);
            let simdReg = FloatReg::new(phyReg, FloatContentType::Simd128);

            if FloatRegSet::contains(set, singleReg) || FloatRegSet::contains(set, doubleReg) || FloatRegSet::contains(set, simdReg) {
                res = false;
            }
        }

        res
    }

    #[refined]
    fn reducedForPush(set: FloatRegSet) -> FloatRegSet {
        if FloatRegSet::isEmpty(set) {
            return set;
        }

        let mut newSet = set;
        for phyReg in PhyFloatReg asc {
            let singleReg = FloatReg::new(phyReg, FloatContentType::Single);
            let doubleReg = FloatReg::new(phyReg, FloatContentType::Double);
            let simdReg = FloatReg::new(phyReg, FloatContentType::Simd128);

            if FloatRegSet::contains(newSet, simdReg) {
                FloatRegSet::take(out newSet, newSet, doubleReg);
                FloatRegSet::take(out newSet, newSet, singleReg);
            } else if FloatRegSet::contains(newSet, doubleReg) {
                FloatRegSet::take(out newSet, newSet, singleReg);
            }
        }

        newSet
    }
}

struct LiveRegSet;

impl LiveRegSet {
    fn gprs(set: LiveRegSet) -> GeneralRegSet;
    fn fpus(set: LiveRegSet) -> FloatRegSet;

    fn containsReg(set: LiveRegSet, reg: Reg) -> Bool {
        let gprs = LiveRegSet::gprs(set);
        GeneralRegSet::contains(gprs, reg)
    }

    fn addReg(out newSet: LiveRegSet, set: LiveRegSet, reg: Reg) {
        let gprs = LiveRegSet::gprs(set);
        let fpus = LiveRegSet::fpus(set);

        GeneralRegSet::add(out gprs, gprs, reg);
        newSet = LiveRegSet::new(gprs, fpus);
    }

    fn takeReg(out newSet: LiveRegSet, set: LiveRegSet, reg: Reg) {
        let gprs = LiveRegSet::gprs(set);
        let fpus = LiveRegSet::fpus(set);

        GeneralRegSet::take(out gprs, gprs, reg);
        newSet = LiveRegSet::new(gprs, fpus);
    }

    fn containsFloatReg(set: LiveRegSet, floatReg: FloatReg) -> Bool {
        let fpus = LiveRegSet::fpus(set);
        FloatRegSet::contains(fpus, floatReg)
    }

    fn addFloatReg(out newSet: LiveRegSet, set: LiveRegSet, floatReg: FloatReg) {
        let gprs = LiveRegSet::gprs(set);
        let fpus = LiveRegSet::fpus(set);

        FloatRegSet::add(out fpus, fpus, floatReg);
        newSet = LiveRegSet::new(gprs, fpus);
    }

    fn takeFloatReg(out newSet: LiveRegSet, set: LiveRegSet, floatReg: FloatReg) {
        let gprs = LiveRegSet::gprs(set);
        let fpus = LiveRegSet::fpus(set);

        FloatRegSet::take(out fpus, fpus, floatReg);
        newSet = LiveRegSet::new(gprs, fpus);
    }

    fn newEmpty() -> LiveRegSet {
        let gprs = GeneralRegSet::newEmpty();
        let fpus = FloatRegSet::newEmpty();
        LiveRegSet::new(gprs, fpus)
    }

    fn new(gprs: GeneralRegSet, fpus: FloatRegSet) -> LiveRegSet {
        let set = (unsafe { LiveRegSet::newUnchecked(gprs, fpus) });
        assume LiveRegSet::gprs(set) == gprs;
        assume LiveRegSet::fpus(set) == fpus;
        set
    }

    unsafe fn newUnchecked(gprs: GeneralRegSet, fpus: FloatRegSet) -> LiveRegSet;
}

enum Condition {
    Equal,
    NotEqual,
    Overflow,
    Zero,
    NonZero,
    Signed,
    NotSigned,
    GreaterThan,
    LessThan,
}

struct Address;

impl Address {
    fn new(base: Reg, offset: Int32) -> Address {
        let address = (unsafe { Address::newUnchecked(base, offset) } );
        assume Address::base(address) == base;
        assume Address::offset(address) == offset;
        address
    }

    unsafe fn newUnchecked(base: Reg, offset: Int32) -> Address;

    fn base(address: Address) -> Reg;
    fn offset(address: Address) -> Int32;
}

enum ABIFunction {
    EqualStringsHelperPure
}

impl ABIFunction {
    #[spec]
    fn call(function: ABIFunction) {
        if function == ABIFunction::EqualStringsHelperPure {
            let str1 = MASM::getString(Reg::Rcx);
            let str2 = MASM::getString(Reg::Rdx);

            ABIFunction::clobberVolatileRegs();

            let equal = EqualStringsHelperPure(str1, str2);
            MASM::setBool(Reg::Rax, equal);
        } else {
            assert false;
        }
    }

    #[spec]
    fn clobberVolatileRegs();
}


ir MASM {
    op Mov(srcReg: Reg, dstReg: Reg) {
        MASM::setInt32(dstReg, MASM::getInt32(srcReg));
    }

    op Move32Imm32(srcInt32: Int32, dstReg: Reg) {
        MASM::setInt32(dstReg, srcInt32);
    }

    op Cmp32Move32(condition: Condition, lhsReg: Reg, rhsReg: Reg, srcReg: Reg, dstReg: Reg) {
        assert (condition == Condition::GreaterThan || condition == Condition::LessThan);

        let lhsInt32 = MASM::getInt32(lhsReg);
        let rhsInt32 = MASM::getInt32(rhsReg);
        let srcInt32 = MASM::getInt32(srcReg);

        if condition == Condition::GreaterThan && lhsInt32 > rhsInt32 {
            MASM::setInt32(dstReg, srcInt32);
        } else if condition == Condition::LessThan && lhsInt32 < rhsInt32 {
            MASM::setInt32(dstReg, srcInt32);
        }
    }

    op MoveBool(srcReg: Reg, dstReg: Reg) {
        MASM::setBool(dstReg, MASM::getBool(srcReg));
    }

    op Jump(label target: MASM) {
        goto target;
    }

    op LoadTypedOrValueAddress(address: Address, dstReg: TypedOrValueReg) {
        let baseData = MASM::getData(Address::base(address));    
        let data = RegData::readData(baseData, Address::offset(address));
        let value = RegData::toValue(data);

        if TypedOrValueReg::hasValue(dstReg) {
            MASM::setValue(TypedOrValueReg::toValueReg(dstReg), value);
        } else {
            assert TypedOrValueReg::hasTyped(dstReg);
            MASM::loadUnboxedValue(value, TypedOrValueReg::type(dstReg),
                TypedOrValueReg::toTypedReg(dstReg));
        }
    }

    op LoadPtrAddress(address: Address, dstReg: Reg) {
        let baseData = MASM::getData(Address::base(address));
        let data = RegData::readData(baseData, Address::offset(address));
        MASM::setData(dstReg, data);
    }

    op UnboxObject(valueReg: ValueReg, objectReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setObject(objectReg, Value::toObject(value));
    }

    op FallibleUnboxBoolean(valueReg: ValueReg, boolReg: Reg, label failure: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsBool = Value::isBool(value);

        if !valueIsBool {
            goto failure;
        }

        let bool = Value::toBool(value);
        MASM::setBool(boolReg, bool);
    }

    op UnboxInt32(valueReg: ValueReg, int32Reg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setInt32(int32Reg, Value::toInt32(value)); 
    }

    op UnboxNonDouble(valueReg: ValueReg, dstReg: Reg, valTy: JSValueType) {
        let value = MASM::getValue(valueReg);
        MASM::unboxNonDouble(value, dstReg, valTy);
    }

    // NOTE: This Op needs to be implemented as a Phantom Op on the
    // C++ side since Firefox implicitly reinterprets booleans
    // as int32 within registers.
    op CastBoolToInt32(int32Reg: Reg) {
        let bool = MASM::getBool(int32Reg);
        if bool {
            MASM::setInt32(int32Reg, 1_i32);
        } else {
            MASM::setInt32(int32Reg, 0_i32);
        }
    }

    op BranchTestNumber(
        condition: Condition,
        valueReg: ValueReg,
        label branch: MASM,
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);

        let valueIsNumber = Value::isInt32(value) || Value::isDouble(value);

        if condition == Condition::Equal && valueIsNumber {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsNumber {
            goto branch;
        }
    }

    op BranchTestNumberTag(
        condition: Condition,
        tagReg: Reg,
        label branch: MASM,
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let tag = MASM::getValueTag(tagReg);

        let valueIsNumber = tag == ValueType::Int32 || tag == ValueType::Double;

        if condition == Condition::Equal && valueIsNumber {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsNumber {
            goto branch;
        }
    }

    op BranchTestBoolean(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsBool = Value::isBool(value);

        if condition == Condition::Equal && valueIsBool {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsBool {
            goto branch;
        }
    }

    op BranchTestString(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsString = Value::isString(value);

        if condition == Condition::Equal && valueIsString {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsString {
            goto branch;
        }
    }

    op BranchTestSymbol(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsSymbol = Value::isSymbol(value);

        if condition == Condition::Equal && valueIsSymbol {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsSymbol {
            goto branch;
        }
    }

    op BranchTestBigInt(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsBigInt = Value::isBigInt(value);

        if condition == Condition::Equal && valueIsBigInt {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsBigInt {
            goto branch;
        }
    }

    op BranchTestNull(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let value = MASM::getValue(valueReg);
        let valueIsNull = Value::isNull(value);

        if condition == Condition::Equal {
            if valueIsNull {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsNull {
                goto branch;
            }
        }
    }

    op BranchTestObject(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsObject = Value::isObject(value);

        if condition == Condition::Equal {
            if valueIsObject {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsObject {
                goto branch;
            }
        }
    }

    op BranchTestObjClass(
        condition: Condition, objectReg: Reg, class: Class, scratchReg: Reg, spectreRegToZero: Reg,
        label branch: MASM
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        assert scratchReg != spectreRegToZero;

        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        MASM::setData(scratchReg, RegData::fromClass(class));

        let objectHasClass = Shape::classOf(shape) == class;

        if condition == Condition::Equal && objectHasClass {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasClass {
            goto branch;
        }

        MASM::setInt32(scratchReg, 0_i32);
    }

    op BranchTestObjClassNoSpectreMitigations(
        condition: Condition, objectReg: Reg, class: Class, scratchReg: Reg, label branch: MASM
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        MASM::setData(scratchReg, RegData::fromClass(class));

        let objectHasClass = Shape::classOf(shape) == class;

        if condition == Condition::Equal && objectHasClass {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasClass {
            goto branch;
        }
    }

    op BranchTestObjectShape(
        condition: Condition, objectReg: Reg, shape: Shape, scratchReg: Reg, spectreRegToZero: Reg,
        label branch: MASM
    ) {
        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        MASM::setInt32(scratchReg, 0_i32);

        if condition == Condition::Equal && objectHasShape {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasShape {
            goto branch;
        }
    }

    op BranchTestObjectShapeNoSpectreMitigations(
        condition: Condition, objectReg: Reg, shape: Shape, label branch: MASM
    ) {
        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        if condition == Condition::Equal && objectHasShape {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasShape {
            goto branch;
        }
    }

    op BranchTestUndefined(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let value = MASM::getValue(valueReg);
        let valueIsUndefined = Value::isUndefined(value);

        if condition == Condition::Equal && valueIsUndefined{
            goto branch;
        }

        if condition == Condition::NotEqual && !valueIsUndefined {
            goto branch;
        }
    }

    op BranchTestInt32(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsInt32 = Value::isInt32(value);

        if condition == Condition::Equal {
            if valueIsInt32 {
                goto branch;
            }
        } else if condition == Condition::NotEqual {
            if !valueIsInt32 {
                goto branch;
            }
        } else {
            assert false;
        }
    }

    op BranchTest32(condition: Condition, lhsReg: Reg, rhsReg: Reg, label branch: MASM) {
        let lhsInt32 = MASM::getInt32(lhsReg);
        let rhsInt32 = MASM::getInt32(rhsReg);

        let result = lhsInt32 & rhsInt32;

        assert (
                condition == Condition::Zero ||
                condition == Condition::NonZero ||
                condition == Condition::Signed ||
                condition == Condition::NotSigned
               );

        if condition == Condition::Zero {
            if result == 0_i32 {
                goto branch;
            }
        } else if condition == Condition::NonZero {
            if result != 0_i32 {
                goto branch;
            }
        } else if condition == Condition::Signed {
            if result < 0_i32 {
                goto branch;
            }
        } else if condition == Condition::NotSigned {
            if result > 0_i32 {
                goto branch;
            }
        }
    }

    op BranchTest32Imm(condition: Condition, lhsReg: Reg, rhsInt32: Int32, label branch: MASM) {
        let lhsInt32 = MASM::getInt32(lhsReg);

        let result = lhsInt32 & rhsInt32;

        assert (
                condition == Condition::Zero ||
                condition == Condition::NonZero ||
                condition == Condition::Signed ||
                condition == Condition::NotSigned
               );

        if condition == Condition::Zero {
            if result == 0_i32 {
                goto branch;
            }
        } else if condition == Condition::NonZero {
            if result != 0_i32 {
                goto branch;
            }
        } else if condition == Condition::Signed {
            if result < 0_i32 {
                goto branch;
            }
        } else if condition == Condition::NotSigned {
            if result > 0_i32 {
                goto branch;
            }
        }
    }

    op Branch32Tag(condition: Condition, lhsReg: Reg, rhsReg: Reg, label branch: MASM) {
        assert (
            condition == Condition::Equal || condition == Condition::NotEqual
        );

        let lhsTag = MASM::getValueTag(lhsReg);
        let rhsTag = MASM::getValueTag(rhsReg);

        if condition == Condition::Equal && lhsTag == rhsTag {
            goto branch;
        } else if condition == Condition::NotEqual && lhsTag != rhsTag {
            goto branch;
        }
    }

    // NOTE: This Op needs to be implemented on the C++ to delegate to the
    // appropriate overload of Branch32Imm since Cachet doesn't have overloading.
    op Branch32Imm(condition: Condition, lhsReg: Reg, rhsInt32: Int32, label branch: MASM) {
        assert (
            condition == Condition::Equal ||
            condition == Condition::NotEqual ||
            condition == Condition::LessThan
        );

        let lhsInt32 = MASM::getInt32(lhsReg);

        if condition == Condition::Equal && lhsInt32 == rhsInt32 {
            goto branch;
        } else if condition == Condition::NotEqual && lhsInt32 != rhsInt32 {
            goto branch;
        } else if condition == Condition::LessThan && lhsInt32 < rhsInt32 {
            goto branch;
        }
    }

    op Branch32AddressImm32(
        condition: Condition, address: Address, rhsInt32: Int32, label branch:MASM
    ) {
        assert (
            condition == Condition::Equal ||
            condition == Condition::NotEqual ||
            condition == Condition::LessThan
        );


        let baseData = MASM::getData(Address::base(address));
        let data = RegData::readData(baseData, Address::offset(address));
        let lhsInt32 = Value::toInt32(RegData::toUnboxedValue(data));

        if condition == Condition::Equal && lhsInt32 == rhsInt32 {
            goto branch;
        } else if condition == Condition::NotEqual && lhsInt32 != rhsInt32 {
            goto branch;
        } else if condition == Condition::LessThan && lhsInt32 < rhsInt32 {
            goto branch;
        }
    }

    op BranchIfNonNativeObj(objectReg: Reg, scratchReg: Reg, label branch: MASM) {
        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        MASM::setData(scratchReg, RegData::fromClass(class));
        let objectIsNative = Class::isNativeObject(class);

        if !objectIsNative {
            goto branch;
        }
    }

    op BranchTestObjectIsProxy(proxy: Bool, objectReg: Reg, scratchReg: Reg, label branch: MASM) {
        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        MASM::setData(scratchReg, RegData::fromClass(class));
        let objectIsProxy = Class::isProxyObject(class);

        if !proxy && !objectIsProxy {
            goto branch;
        } else if proxy && objectIsProxy {
            goto branch;
        }
    }

    op GuardSpecificAtom(
        strReg: Reg, atom: Atom, scratchReg: Reg, volatileRegs: LiveRegSet, label fail: MASM
    ) {
        let str = MASM::getString(strReg);
        if str == atom {
            return;
        }

        if String::isAtom(str) {
            goto fail;
        }

        if String::length(str) != String::length(atom) {
            goto fail;
        }

        MASM::pushRegsInMask(volatileRegs);

        MASM::setString(scratchReg, atom);
        MASM::setString(Reg::Rcx, MASM::getString(scratchReg));
        MASM::setString(Reg::Rdx, str);

        ABIFunction::call(ABIFunction::EqualStringsHelperPure);
        MASM::setBool(scratchReg, MASM::getBool(Reg::Rax));

        assert !LiveRegSet::containsReg(volatileRegs, scratchReg);
        MASM::popRegsInMask(volatileRegs);

        let result = MASM::getBool(scratchReg);
        if !result {
            goto fail;
        }
    }

    op TagValue(valTy: JSValueType, payload: Reg, dest: ValueReg) {
        // TODO: Don't have getters/setters for other types yet
        if valTy == JSValueType::Int32 {
            let i = MASM::getInt32(payload);
            let val = Value::fromInt32(i);
            MASM::setValue(dest, val);
        } else if valTy == JSValueType::Bool {
            let b = MASM::getBool(payload);
            let val = Value::fromBool(b);
            MASM::setValue(dest, val);
        } else if valTy == JSValueType::String {
            let s = MASM::getString(payload);
            let val = Value::fromString(s);
            MASM::setValue(dest, val);
        } else if valTy == JSValueType::Symbol {
            let s = MASM::getSymbol(payload);
            let val = Value::fromSymbol(s);
            MASM::setValue(dest, val);
        } else if valTy == JSValueType::BigInt {
            let b = MASM::getBigInt(payload);
            let val = Value::fromBigInt(b);
            MASM::setValue(dest, val);
        }

        assert false;
    }

    op BranchAdd32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
        let lhsInt32 = MASM::getInt32(srcReg);
        let rhsInt32 = MASM::getInt32(dstReg);

        let result = lhsInt32 + rhsInt32;

        assert condition == Condition::Overflow;
        if lhsInt32 > 0_i32 && rhsInt32 > 0_i32 && result < 0_i32 {
            goto branch;
        }

        if lhsInt32 < 0_i32 && rhsInt32 < 0_i32 && result > 0_i32 {
            goto branch;
        }

        MASM::setInt32(dstReg, result);
    }

    // this op corresponds to an overload of the BranchAdd32 MASM op.
    op BranchAdd32Imm(condition: Condition, lhsInt32: Int32, dstReg: Reg, label branch: MASM) {
        let rhsInt32 = MASM::getInt32(dstReg);

        let result = lhsInt32 + rhsInt32;

        assert condition == Condition::Overflow;
        if lhsInt32 > 0_i32 && rhsInt32 > 0_i32 && result < 0_i32 {
            goto branch;
        }

        if lhsInt32 < 0_i32 && rhsInt32 < 0_i32 && result > 0_i32 {
            goto branch;
        }

        MASM::setInt32(dstReg, result);
    }

    op BranchSub32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
        let lhsInt32 = MASM::getInt32(dstReg);
        let rhsInt32 = MASM::getInt32(srcReg);

        let result = lhsInt32 - rhsInt32;

        assert condition == Condition::Overflow;

        let rhsInt32Neg = -rhsInt32;
        let minInt32 = 1_i32 << 31_i32; // Do it this way until negative literals are a thing

        if rhsInt32 == minInt32 && lhsInt32 >= 0_i32 {
            goto branch;
        } else if lhsInt32 > 0_i32 && rhsInt32 < 0_i32 && result < 0_i32 {
            goto branch;
        }

        if lhsInt32 < 0_i32 && rhsInt32 > 0_i32 && result > 0_i32 {
            goto branch;
        }

        MASM::setInt32(dstReg, result);
    }

    // this op corresponds to an overload of the BranchAdd32 MASM op.
    op BranchSub32Imm(condition: Condition, rhsInt32: Int32, dstReg: Reg, label branch: MASM) {
        let lhsInt32 = MASM::getInt32(dstReg);

        let result = lhsInt32 - rhsInt32;

        assert condition == Condition::Overflow;

        let rhsInt32Neg = -rhsInt32;
        let minInt32 = 1_i32 << 31_i32; // Do it this way until negative literals are a thing

        if rhsInt32 == minInt32 && lhsInt32 >= 0_i32 {
            goto branch;
        } else if lhsInt32 > 0_i32 && rhsInt32 < 0_i32 && result < 0_i32 {
            goto branch;
        }

        if lhsInt32 < 0_i32 && rhsInt32 > 0_i32 && result > 0_i32 {
            goto branch;
        }

        MASM::setInt32(dstReg, result);
    }

    op BranchMul32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
        let lhsInt32 = MASM::getInt32(dstReg);
        let rhsInt32 = MASM::getInt32(srcReg);

        let result = lhsInt32 * rhsInt32;

        assert condition == Condition::Overflow;

        let resultWide = (lhsInt32 as Int64) * (rhsInt32 as Int64);
        if (result as Int64) != resultWide {
            goto branch;
        }

        MASM::setInt32(dstReg, result);
    }

    op Neg32(valueReg: Reg) {
        let valueInt32 = MASM::getInt32(valueReg);
        let result = -valueInt32;

        MASM::setInt32(valueReg, result);
    }

    op Or32(srcReg: Reg, dstReg: Reg) {
        let lhsInt32 = MASM::getInt32(srcReg);
        let rhsInt32 = MASM::getInt32(dstReg);

        let result = lhsInt32 | rhsInt32;

        MASM::setInt32(dstReg, result);
    }

    #[spec]
    fn loadUnboxedValue(value: Value, type: MIRType, dstReg: AnyReg) {
        if AnyReg::isFloat(dstReg) {
            MASM::loadInt32OrDouble(value, AnyReg::toFloatReg(dstReg));
        } else {
            MASM::unboxNonDouble(value, AnyReg::toReg(dstReg), JSValueType::fromMIRType(type));
        }
    }

    #[spec]
    fn unboxNonDouble(value: Value, dstReg: Reg, valTy: JSValueType) {
        assert valTy != JSValueType::Double;

        if valTy == JSValueType::Object {
            let o = Value::toObject(value);
            MASM::setObject(dstReg, o);
        } else if valTy == JSValueType::Int32 {
            let i = Value::toInt32(value);
            MASM::setInt32(dstReg, i);
        } else if valTy == JSValueType::Bool {
            let b = Value::toBool(value);
            MASM::setBool(dstReg, b);
        } else if valTy == JSValueType::String {
            let s = Value::toString(value);
            MASM::setString(dstReg, s);
        } else if valTy == JSValueType::Symbol {
            let s = Value::toSymbol(value);
            MASM::setSymbol(dstReg, s);
        } else if valTy == JSValueType::BigInt {
            let b = Value::toBigInt(value);
            MASM::setBigInt(dstReg, b);
        }

        assert false;
    }

    #[spec]
    fn loadInt32OrDouble(value: Value, dstReg: FloatReg) {
        if Value::isInt32(value) {
            let int32 = Value::toInt32(value);
            let double = Float64::fromInt32(int32);
            MASM::setDouble(dstReg, double);
        } else if Value::isDouble(value) {
            let double = Value::toDouble(value);
            MASM::setDouble(dstReg, double);
        }

        assert false;
    }

    #[spec]
    fn getData(reg: Reg) -> RegData;
    #[spec]
    fn setData(reg: Reg, data: RegData);

    #[spec]
    fn getValueTag(reg: Reg) -> ValueType {
        RegData::toValueType(MASM::getData(reg))
    }

    #[spec]
    fn setValueTag(reg:Reg, tag: ValueType) {
        MASM::setData(reg, RegData::fromValueType(tag));
    }

    fn getValue(valueReg: ValueReg) -> Value;
    fn setValue(valueReg: ValueReg, value: Value);

    fn getInt32(reg: Reg) -> Int32;
    fn setInt32(reg: Reg, int32: Int32);

    fn getObject(reg: Reg) -> Object;
    fn setObject(reg: Reg, object: Object);

    fn getBool(reg: Reg) -> Bool;
    fn setBool(reg: Reg, bool: Bool);

    fn getString(reg: Reg) -> String;
    fn setString(reg: Reg, string: String);

    fn getSymbol(reg: Reg) -> Symbol;
    fn setSymbol(reg: Reg, symbol: Symbol);

    fn getBigInt(reg: Reg) -> BigInt;
    fn setBigInt(reg: Reg, bigInt: BigInt);

    fn getDouble(floatReg: FloatReg) -> Float64;
    fn setDouble(floatReg: FloatReg, double: Float64);

    #[spec]
    fn setHasPushedRegs();
    #[spec]
    fn unsetHasPushedRegs();

    #[spec]
    fn stackPushLiveGeneralReg(reg: Reg);
    #[spec]
    fn stackPopLiveGeneralReg(reg: Reg);

    #[spec]
    fn stackPushLiveFloatReg(floatReg: FloatReg);
    #[spec]
    fn stackPopLiveFloatReg(floatReg: FloatReg);

    #[refined]
    fn pushRegsInMask(set: LiveRegSet) {
        MASM::setHasPushedRegs();
        let gprs = LiveRegSet::gprs(set);
        let fpus = LiveRegSet::fpus(set);

        for reg in Reg desc {
            if GeneralRegSet::contains(gprs, reg) {
                MASM::stackPushLiveGeneralReg(reg);
            }
        }

        for phyReg in PhyFloatReg desc {
            let singleReg = FloatReg::new(phyReg, FloatContentType::Single);
            let doubleReg = FloatReg::new(phyReg, FloatContentType::Double);
            let simdReg = FloatReg::new(phyReg, FloatContentType::Simd128);

            if FloatRegSet::contains(fpus, simdReg) {
                MASM::stackPushLiveFloatReg(simdReg);
            } else if FloatRegSet::contains(fpus, doubleReg) {
                MASM::stackPushLiveFloatReg(doubleReg);
            } else if FloatRegSet::contains(fpus, singleReg) {
                MASM::stackPushLiveFloatReg(singleReg);
            }
        }
    }

    #[refined]
    fn popRegsInMaskIgnore(set: LiveRegSet, ignore: LiveRegSet) {
        let fpus = FloatRegSet::reducedForPush(LiveRegSet::fpus(set)); 
        let gprs = LiveRegSet::gprs(set);


        let fpusIgnore = LiveRegSet::fpus(ignore);
        let fpusPop = FloatRegSet::newDifference(fpus, fpusIgnore);

        for phyReg in PhyFloatReg desc {
            let singleReg = FloatReg::new(phyReg, FloatContentType::Single);
            let doubleReg = FloatReg::new(phyReg, FloatContentType::Double);
            let simdReg = FloatReg::new(phyReg, FloatContentType::Simd128);

            if FloatRegSet::contains(fpusPop, simdReg) {
                MASM::stackPopLiveFloatReg(simdReg);
            } else if FloatRegSet::contains(fpusPop, doubleReg) {
                MASM::stackPopLiveFloatReg(doubleReg);
            } else if FloatRegSet::contains(fpusPop, singleReg) {
                MASM::stackPopLiveFloatReg(singleReg);
            }
        }


        let gprsIgnore = LiveRegSet::gprs(ignore);
        let gprsPop = GeneralRegSet::newDifference(gprs, gprsIgnore);

        for reg in Reg desc {
            if GeneralRegSet::contains(gprsPop, reg) {
                MASM::stackPopLiveGeneralReg(reg);
            }
        }

        MASM::unsetHasPushedRegs();
    }

    #[refined]
    fn popRegsInMask(set: LiveRegSet) {
        let ignore = LiveRegSet::newEmpty();
        MASM::popRegsInMaskIgnore(set, ignore);
    }
}
