// vim: set tw=99 ts=4 sts=4 sw=4 et:

import "./JSOp.cachet";
import "./VM.cachet";

enum Reg {
    Rax,
    Rcx,
    Rdx,
    Rbx,
    Rsp,
    Rbp,
    Rsi,
    Rdi,
    R8,
    R9,
    R10,
    R11,
    R12,
    R13,
    R14,
    R15,
}

impl Reg {
    fn scratchReg() -> Reg {
        Reg::R11
    }
}

struct MaybeReg;

impl MaybeReg {
    fn isReg(maybeReg: MaybeReg) -> Bool;

    fn none() -> MaybeReg {
        let maybeReg = (unsafe { MaybeReg::noneUnchecked() });
        assume !MaybeReg::isReg(maybeReg);
        maybeReg
    }

    unsafe fn noneUnchecked() -> MaybeReg;

    fn fromReg(reg: Reg) -> MaybeReg {
        let maybeReg = (unsafe { MaybeReg::fromRegUnchecked(reg) });
        assume MaybeReg::isReg(maybeReg);
        assume (unsafe { MaybeReg::toRegUnchecked(maybeReg) }) == reg;
        maybeReg
    }

    unsafe fn fromRegUnchecked(reg: Reg) -> MaybeReg;

    fn toReg(maybeReg: MaybeReg) -> Reg {
        assert MaybeReg::isReg(maybeReg);
        let reg = (unsafe { MaybeReg::toRegUnchecked(maybeReg) });
        assume (unsafe { MaybeReg::fromRegUnchecked(reg) }) == maybeReg;
        reg
    }

    unsafe fn toRegUnchecked(maybeReg: MaybeReg) -> Reg;
}

// Used for ValueOperand as well
// #[cfg(cpp)]
struct ValueReg;
// #[cfg(verify)]
// type ValueReg = Reg;

impl ValueReg {
    fn scratchReg(valueReg: ValueReg) -> Reg;
}

enum PhyFloatReg {
    Xmm0,
    Xmm1,
    Xmm2,
    Xmm3,
    Xmm4,
    Xmm5,
    Xmm6,
    Xmm7,
    Xmm8,
    Xmm9,
    Xmm10,
    Xmm11,
    Xmm12,
    Xmm13,
    Xmm14,
    Xmm15,
}

enum FloatContentType {
    Single,
    Double,
    Simd128,
}

struct FloatReg {
   reg: PhyFloatReg,
   type: FloatContentType,
}

impl FloatReg {
    fn new(reg: PhyFloatReg, type: FloatContentType) -> FloatReg {
        let floatReg = (unsafe { FloatReg::newUnchecked(reg, type) });
        assume floatReg.reg == reg;
        assume floatReg.type == type;
        floatReg
    }

    fn newDouble(reg: PhyFloatReg) -> FloatReg {
        FloatReg::new(reg, FloatContentType::Double)
    }

    unsafe fn newUnchecked(reg: PhyFloatReg, type: FloatContentType) -> FloatReg;

    fn floatReg0() -> FloatReg {
        FloatReg::newDouble(PhyFloatReg::Xmm0)
    }

    fn doubleScratchReg() -> FloatReg {
        FloatReg::newDouble(PhyFloatReg::Xmm15)
    }
}

struct AnyReg;

impl AnyReg {
    fn isFloat(anyReg: AnyReg) -> Bool;

    fn fromReg(reg: Reg) -> AnyReg {
       let anyReg = (unsafe { AnyReg::fromRegUnchecked(reg) });
       assume !AnyReg::isFloat(anyReg);
       assume (unsafe { AnyReg::toRegUnchecked(anyReg) }) == reg;
       anyReg
    }

    unsafe fn fromRegUnchecked(reg: Reg) -> AnyReg;

    fn toReg(anyReg: AnyReg) -> Reg {
        assert !AnyReg::isFloat(anyReg);
        let reg = (unsafe { AnyReg::toRegUnchecked(anyReg) });
        assume (unsafe { AnyReg::fromRegUnchecked(reg) }) == anyReg;
        reg
    }

    unsafe fn toRegUnchecked(anyReg: AnyReg) -> Reg;

    fn fromFloatReg(floatReg: FloatReg) -> AnyReg {
        let anyReg = (unsafe { AnyReg::fromFloatRegUnchecked(floatReg) });
        assume AnyReg::isFloat(anyReg);
        assume (unsafe { AnyReg::toFloatRegUnchecked(anyReg) }) == floatReg;
        anyReg
    }

    unsafe fn fromFloatRegUnchecked(floatReg: FloatReg) -> AnyReg;

    fn toFloatReg(anyReg: AnyReg) -> FloatReg {
        assert AnyReg::isFloat(anyReg);
        let floatReg = (unsafe { AnyReg::toFloatRegUnchecked(anyReg) });
        assume (unsafe { AnyReg::fromFloatRegUnchecked(floatReg) }) == anyReg;
        floatReg
    }

    unsafe fn toFloatRegUnchecked(anyReg: AnyReg) -> FloatReg;
}

struct TypedOrValueReg;

impl TypedOrValueReg {
    fn type(reg: TypedOrValueReg) -> MIRType;

    fn hasTyped(reg: TypedOrValueReg) -> Bool {
        let type = TypedOrValueReg::type(reg);
        type != MIRType::Value && type != MIRType::None
    }

    fn hasValue(reg: TypedOrValueReg) -> Bool {
        TypedOrValueReg::type(reg) == MIRType::Value
    }

    fn fromValueReg(valueReg: ValueReg) -> TypedOrValueReg {
        let reg = (unsafe { TypedOrValueReg::fromValueRegUnchecked(valueReg) });
        assume TypedOrValueReg::type(reg) == MIRType::Value;
        assume (unsafe { TypedOrValueReg::toValueRegUnchecked(reg) }) == valueReg;
        reg
    }

    unsafe fn fromValueRegUnchecked(valueReg: ValueReg) -> TypedOrValueReg;

    fn toValueReg(reg: TypedOrValueReg) -> ValueReg {
        assert TypedOrValueReg::hasValue(reg);
        let valueReg = (unsafe { TypedOrValueReg::toValueRegUnchecked(reg) });
        assume (unsafe { TypedOrValueReg::fromValueRegUnchecked(valueReg) }) == reg;
        valueReg
    }

    unsafe fn toValueRegUnchecked(reg: TypedOrValueReg) -> ValueReg;

    fn fromTypedReg(type: MIRType, typedReg: AnyReg) -> TypedOrValueReg {
        // NOTE: don't support this currently even though it may be okay
        assert type != MIRType::Value;

        let reg = (unsafe { TypedOrValueReg::fromTypedRegUnchecked(type, typedReg) });
        assume TypedOrValueReg::type(reg) == type;
        assume (unsafe { TypedOrValueReg::toTypedRegUnchecked(reg) }) == typedReg;
        reg
    }

    unsafe fn fromTypedRegUnchecked(type: MIRType, reg: AnyReg) -> TypedOrValueReg;

    fn toTypedReg(reg: TypedOrValueReg) -> AnyReg {
       assert TypedOrValueReg::hasTyped(reg);
       let typedReg = (unsafe { TypedOrValueReg::toTypedRegUnchecked(reg) });
       let type = TypedOrValueReg::type(reg);
       assume (unsafe { TypedOrValueReg::fromTypedRegUnchecked(type, typedReg) }) == reg;
       typedReg
    }

    unsafe fn toTypedRegUnchecked(reg: TypedOrValueReg) -> AnyReg;
}

struct GeneralRegSet;

impl GeneralRegSet {
    fn empty() -> GeneralRegSet;
    fn volatile() -> GeneralRegSet;

    fn intersect(lhs: GeneralRegSet, rhs: GeneralRegSet) -> GeneralRegSet;
    fn difference(lhs: GeneralRegSet, rhs: GeneralRegSet) -> GeneralRegSet;

    #[refined]
    fn isEmpty(set: GeneralRegSet) -> Bool {
        for reg in Reg asc {
            if GeneralRegSet::contains(set, reg) {
                return false;
            }
        }
        true
    }

    fn contains(set: GeneralRegSet, reg: Reg) -> Bool;
    fn add(out newSet: GeneralRegSet, set: GeneralRegSet, reg: Reg);
    fn take(out newSet: GeneralRegSet, set: GeneralRegSet, reg: Reg);
}

struct FloatRegSet;

impl FloatRegSet {
    fn empty() -> FloatRegSet;
    fn volatile() -> FloatRegSet;

    fn intersect(lhs: FloatRegSet, rhs: FloatRegSet) -> FloatRegSet;
    fn difference(lhs: FloatRegSet, rhs: FloatRegSet) -> FloatRegSet;

    #[refined]
    fn isEmpty(set: FloatRegSet) -> Bool {
        for phyReg in PhyFloatReg asc {
            let singleReg = FloatReg::new(phyReg, FloatContentType::Single);
            let doubleReg = FloatReg::new(phyReg, FloatContentType::Double);
            let simdReg = FloatReg::new(phyReg, FloatContentType::Simd128);
            if FloatRegSet::contains(set, singleReg) || FloatRegSet::contains(set, doubleReg) || FloatRegSet::contains(set, simdReg) {
                return false;
            }
        }
        true
    }

    fn contains(set: FloatRegSet, floatReg: FloatReg) -> Bool;
    fn add(out newSet: FloatRegSet, set: FloatRegSet, floatReg: FloatReg);
    fn take(out newSet: FloatRegSet, set: FloatRegSet, floatReg: FloatReg);

    #[refined]
    fn reducedForPush(set: FloatRegSet) -> FloatRegSet {
        if FloatRegSet::isEmpty(set) {
            return set;
        }

        let mut newSet = set;
        for phyReg in PhyFloatReg asc {
            let singleReg = FloatReg::new(phyReg, FloatContentType::Single);
            let doubleReg = FloatReg::new(phyReg, FloatContentType::Double);
            let simdReg = FloatReg::new(phyReg, FloatContentType::Simd128);

            if FloatRegSet::contains(newSet, simdReg) {
                FloatRegSet::take(out newSet, newSet, doubleReg);
                FloatRegSet::take(out newSet, newSet, singleReg);
            } else if FloatRegSet::contains(newSet, doubleReg) {
                FloatRegSet::take(out newSet, newSet, singleReg);
            }
        }
        newSet
    }
}

struct LiveRegSet;

impl LiveRegSet {
    fn gprs(set: LiveRegSet) -> GeneralRegSet;
    fn fpus(set: LiveRegSet) -> FloatRegSet;

    fn new(gprs: GeneralRegSet, fpus: FloatRegSet) -> LiveRegSet {
        let set = (unsafe { LiveRegSet::newUnchecked(gprs, fpus) });
        assume LiveRegSet::gprs(set) == gprs;
        assume LiveRegSet::fpus(set) == fpus;
        set
    }

    unsafe fn newUnchecked(gprs: GeneralRegSet, fpus: FloatRegSet) -> LiveRegSet;

    fn empty() -> LiveRegSet {
        let gprs = GeneralRegSet::empty();
        let fpus = FloatRegSet::empty();
        LiveRegSet::new(gprs, fpus)
    }

    fn containsReg(set: LiveRegSet, reg: Reg) -> Bool {
        let gprs = LiveRegSet::gprs(set);
        GeneralRegSet::contains(gprs, reg)
    }

    fn addReg(out newSet: LiveRegSet, set: LiveRegSet, reg: Reg) {
        let mut gprs = LiveRegSet::gprs(set);
        let fpus = LiveRegSet::fpus(set);

        GeneralRegSet::add(out gprs, gprs, reg);
        newSet = LiveRegSet::new(gprs, fpus);
    }

    fn takeReg(out newSet: LiveRegSet, set: LiveRegSet, reg: Reg) {
        let mut gprs = LiveRegSet::gprs(set);
        let fpus = LiveRegSet::fpus(set);

        GeneralRegSet::take(out gprs, gprs, reg);
        newSet = LiveRegSet::new(gprs, fpus);
    }

    fn containsFloatReg(set: LiveRegSet, floatReg: FloatReg) -> Bool {
        let fpus = LiveRegSet::fpus(set);
        FloatRegSet::contains(fpus, floatReg)
    }

    fn addFloatReg(out newSet: LiveRegSet, set: LiveRegSet, floatReg: FloatReg) {
        let gprs = LiveRegSet::gprs(set);
        let mut fpus = LiveRegSet::fpus(set);

        FloatRegSet::add(out fpus, fpus, floatReg);
        newSet = LiveRegSet::new(gprs, fpus);
    }

    fn takeFloatReg(out newSet: LiveRegSet, set: LiveRegSet, floatReg: FloatReg) {
        let gprs = LiveRegSet::gprs(set);
        let mut fpus = LiveRegSet::fpus(set);

        FloatRegSet::take(out fpus, fpus, floatReg);
        newSet = LiveRegSet::new(gprs, fpus);
    }
}

#[spec]
struct FloatData;

impl FloatData {
    fn contentType(data: FloatData) -> FloatContentType;

    fn fromDouble(double: Float64) -> FloatData {
        let data = (unsafe { FloatData::fromDoubleUnchecked(double) });
        assume FloatData::contentType(data) == FloatContentType::Double;
        assume (unsafe { FloatData::toDoubleUnchecked(data) }) == double;
        data
    }

    unsafe fn fromDoubleUnchecked(double: Float64) -> FloatData;

    fn toDouble(data: FloatData) -> Float64 {
        assert FloatData::contentType(data) == FloatContentType::Double;
        let double = (unsafe { FloatData::toDoubleUnchecked(data) });
        assume (unsafe { FloatData::fromDoubleUnchecked(double) }) == data;
        double
    }

    unsafe fn toDoubleUnchecked(data: FloatData) -> Float64;

    fn fromFloat(float: Float32) -> FloatData {
        let data = (unsafe { FloatData::fromFloatUnchecked(float) });
        assume FloatData::contentType(data) == FloatContentType::Single;
        assume (unsafe { FloatData::toFloatUnchecked(data) }) == float;
        data
    }

    unsafe fn fromFloatUnchecked(float: Float32) -> FloatData;

    fn toFloat(data: FloatData) -> Float32 {
        assert FloatData::contentType(data) == FloatContentType::Single;
        let float = (unsafe { FloatData::toFloatUnchecked(data) });
        assume (unsafe { FloatData::fromFloatUnchecked(float) }) == data;
        float
    }

    unsafe fn toFloatUnchecked(data: FloatData) -> Float32;

    fn fromSimd128(simd128: Simd128) -> FloatData {
        let data = (unsafe { FloatData::fromSimd128Unchecked(simd128) });
        assume FloatData::contentType(data) == FloatContentType::Simd128;
        assume (unsafe { FloatData::toSimd128Unchecked(data) }) == simd128;
        data
    }

    unsafe fn fromSimd128Unchecked(simd128: Simd128) -> FloatData;

    fn toSimd128(data: FloatData) -> Simd128 {
        assert FloatData::contentType(data) == FloatContentType::Simd128;
        let simd128 = (unsafe { FloatData::toSimd128Unchecked(data) });
        assume (unsafe { FloatData::fromSimd128Unchecked(simd128) }) == data;
        simd128
    }

    unsafe fn toSimd128Unchecked(data: FloatData) -> Simd128;
}

#[spec]
struct SavedGeneralRegs {
    set: GeneralRegSet,
    size: UInt64,
}

impl SavedGeneralRegs {
    fn new(set: GeneralRegSet, size: UInt64) -> SavedGeneralRegs {
        let saved = (unsafe { SavedGeneralRegs::newUnchecked(set, size) });
        assume saved.set == set;
        assume saved.size == size;
        saved
    }

    unsafe fn newUnchecked(set: GeneralRegSet, size: UInt64) -> SavedGeneralRegs;
}

#[spec]
struct SavedFloatRegs {
    set: FloatRegSet,
    size: UInt64,
}

impl SavedFloatRegs {
    fn new(set: FloatRegSet, size: UInt64) -> SavedFloatRegs {
        let saved = (unsafe { SavedFloatRegs::newUnchecked(set, size) });
        assume saved.set == set;
        assume saved.size == size;
        saved
    }

    unsafe fn newUnchecked(set: FloatRegSet, size: UInt64) -> SavedFloatRegs;
}

#[spec]
enum StackDataType {
    Uninitialized,
    RegData,
    FloatData,
    SavedGeneralRegs,
    SavedFloatRegs,
}

#[spec]
struct StackData;

impl StackData {
    fn typeOf(data: StackData) -> StackDataType;

    fn sizeOf(data: StackData) -> UInt64 {
        assert StackData::typeOf(data) != StackDataType::Uninitialized;
        (unsafe { StackData::sizeOfUnchecked(data) })
    }

    unsafe fn sizeOfUnchecked(data: StackData) -> UInt64;

    fn uninitialized() -> StackData {
        let data = (unsafe { StackData::uninitializedUnchecked() });
        assume StackData::typeOf(data) == StackDataType::Uninitialized;
        data
    }

    unsafe fn uninitializedUnchecked() -> StackData;

    fn fromRegData(regData: RegData) -> StackData {
        let data = (unsafe { StackData::fromRegDataUnchecked(regData) });
        assume (unsafe { StackData::toRegDataUnchecked(data) }) == regData;
        assume StackData::typeOf(data) == StackDataType::RegData;
        assume (unsafe { StackData::sizeOfUnchecked(data) }) == 8_u64;
        data
    }

    unsafe fn fromRegDataUnchecked(regData: RegData) -> StackData;

    fn toRegData(data: StackData) -> RegData {
        assert StackData::typeOf(data) == StackDataType::RegData;
        let regData = (unsafe { StackData::toRegDataUnchecked(data) });
        assume (unsafe { StackData::fromRegDataUnchecked(regData) }) == data;
        regData
    }

    unsafe fn toRegDataUnchecked(data: StackData) -> RegData;

    fn fromFloatData(floatData: FloatData) -> StackData {
        let data = (unsafe { StackData::fromFloatDataUnchecked(floatData) });
        assume (unsafe { StackData::toFloatDataUnchecked(data) }) == floatData;
        assume StackData::typeOf(data) == StackDataType::FloatData;

        let contentType = FloatData::contentType(floatData);
        if contentType == FloatContentType::Single {
            assume (unsafe { StackData::sizeOf(data) }) == 4_u64;
        } else if contentType == FloatContentType::Double {
            assume (unsafe { StackData::sizeOf(data) }) == 8_u64;
        } else {
            assume (unsafe { StackData::sizeOf(data) }) == 16_u64;
        }

        data
    }

    unsafe fn fromFloatDataUnchecked(floatData: FloatData) -> StackData;

    fn toFloatData(data: StackData) -> FloatData {
        assert StackData::typeOf(data) == StackDataType::FloatData;
        let floatData = (unsafe { StackData::toFloatDataUnchecked(data) });
        assume (unsafe { StackData::fromFloatDataUnchecked(floatData) }) == data;
        floatData
    }

    unsafe fn toFloatDataUnchecked(data: StackData) -> FloatData;

    fn fromSavedGeneralRegs(saved: SavedGeneralRegs) -> StackData {
        let data = (unsafe { StackData::fromSavedGeneralRegsUnchecked(saved) });
        assume (unsafe { StackData::toSavedGeneralRegsUnchecked(data) }) == saved;
        assume StackData::typeOf(data) == StackDataType::SavedGeneralRegs;
        assume (unsafe { StackData::sizeOf(data) }) == saved.size;
        data
    }

    unsafe fn fromSavedGeneralRegsUnchecked(saved: SavedGeneralRegs) -> StackData;

    fn toSavedGeneralRegs(data: StackData) -> SavedGeneralRegs {
        assert StackData::typeOf(data) == StackDataType::SavedGeneralRegs;
        let saved = (unsafe { StackData::toSavedGeneralRegsUnchecked(data) });
        assume (unsafe { StackData::fromSavedGeneralRegsUnchecked(saved) }) == data;
        saved
    }

    unsafe fn toSavedGeneralRegsUnchecked(data: StackData) -> SavedGeneralRegs;

    fn fromSavedFloatRegs(saved: SavedFloatRegs) -> StackData {
        let data = (unsafe { StackData::fromSavedFloatRegsUnchecked(saved) });
        assume (unsafe { StackData::toSavedFloatRegsUnchecked(data) }) == saved;
        assume StackData::typeOf(data) == StackDataType::SavedFloatRegs;
        assume (unsafe { StackData::sizeOf(data) }) == saved.size;
        data
    }

    unsafe fn fromSavedFloatRegsUnchecked(saved: SavedFloatRegs) -> StackData;

    fn toSavedFloatRegs(data: StackData) -> SavedFloatRegs {
        assert StackData::typeOf(data) == StackDataType::SavedFloatRegs;
        let saved = (unsafe { StackData::toSavedFloatRegsUnchecked(data) });
        assume (unsafe { StackData::fromSavedFloatRegsUnchecked(saved) }) == data;
        saved
    }

    unsafe fn toSavedFloatRegsUnchecked(data: StackData) -> SavedFloatRegs;
}

enum Condition {
    Equal,
    NotEqual,
    Overflow,
    Zero,
    NonZero,
    Signed,
    NotSigned,
    GreaterThan,
    LessThan,
    GreaterThanOrEqual,
    LessThanOrEqual,
    Above,
    Below,
    AboveOrEqual,
    BelowOrEqual,
}

impl Condition {
    fn fromJSOp(jsop: JSOp, isSigned: Bool) -> Condition {
        if jsop == JSOp::Eq || jsop == JSOp::StrictEq {
            return Condition::Equal;
        }
        if jsop == JSOp::Ne || jsop == JSOp::StrictNe {
            return Condition::NotEqual;
        }

        if isSigned {
            if jsop == JSOp::Lt {
                return Condition::LessThan;
            }
            if jsop == JSOp::Le {
                return Condition::LessThanOrEqual;
            }
            if jsop == JSOp::Gt {
                return Condition::GreaterThan;
            }
            assert jsop == JSOp::Ge;
            return Condition::GreaterThanOrEqual;
        } else {
            if jsop == JSOp::Lt {
                return Condition::Below;
            }
            if jsop == JSOp::Le {
                return Condition::BelowOrEqual;
            }
            if jsop == JSOp::Gt {
                return Condition::Above;
            }
            assert jsop == JSOp::Ge;
            return Condition::AboveOrEqual;
        }
    }
}

struct Address {
    base: Reg,
    offset: Int32,
}

impl Address {
    fn new(base: Reg, offset: Int32) -> Address {
        let address = (unsafe { Address::newUnchecked(base, offset) } );
        assume address.base == base;
        assume address.offset == offset;
        address
    }

    unsafe fn newUnchecked(base: Reg, offset: Int32) -> Address;
}

enum Scale {
    TimesOne,
    TimesTwo,
    TimesFour,
    TimesEight,
}

var ValueScale: Scale = Scale::TimesEight;

struct BaseIndex {
    base: Reg,
    index: Reg,
    scale: Scale,
    offset: UInt32,
}

impl BaseIndex {
    fn new(base: Reg, index: Reg, scale: Scale, offset: UInt32) -> BaseIndex {
        let baseIndex = (unsafe { BaseIndex::newUnchecked(base, index, scale, offset) } );
        assume baseIndex.base == base;
        assume baseIndex.index == index;
        assume baseIndex.scale == scale;
        assume baseIndex.offset == offset;
        baseIndex
    }

    unsafe fn newUnchecked(base: Reg, index: Reg, scale: Scale, offset: UInt32) -> BaseIndex;

    #[spec]
    fn getOffset(baseIndex: BaseIndex) -> Int64 {
        let index = (MASM::getInt32(baseIndex.index) as UInt32) as Int64;
        if baseIndex.scale == Scale::TimesOne {
            return index * 1_i64 + baseIndex.offset;
        } else if baseIndex.scale == Scale::TimesTwo {
            return index * 2_i64 + baseIndex.offset;
        } else if baseIndex.scale == Scale::TimesFour {
            return index * 4_i64 + baseIndex.offset;
        } else {
            assert baseIndex.scale == Scale::TimesEight;
            return index * 8_i64 + baseIndex.offset;
        }
    }
}

struct BaseValueIndex <: BaseIndex;

impl BaseValueIndex {
    fn new(base: Reg, index: Reg, offset: UInt32) -> BaseValueIndex {
        let baseValueIndex = (unsafe { BaseValueIndex::newUnchecked(base, index, offset) } );
        assume baseValueIndex == BaseIndex::new(base, index, ValueScale, offset);
        baseValueIndex
    }

    unsafe fn newUnchecked(base: Reg, index: Reg, offset: UInt32) -> BaseValueIndex;
}

struct BaseObjectElementIndex <: BaseValueIndex;

impl BaseObjectElementIndex {
    fn new(base: Reg, index: Reg, offset: UInt32) -> BaseObjectElementIndex {
        let baseObjectElementIndex = (unsafe {
            BaseObjectElementIndex::newUnchecked(base, index, offset)
        });
        assume baseObjectElementIndex == BaseValueIndex::new(base, index, offset);
        baseObjectElementIndex
    }

    unsafe fn newUnchecked(base: Reg, index: Reg, offset: UInt32) -> BaseObjectElementIndex;
}

struct BaseObjectSlotIndex <: BaseValueIndex;

impl BaseObjectSlotIndex {
    fn new(base: Reg, index: Reg) -> BaseObjectSlotIndex {
        let baseObjectSlotIndex = (unsafe { BaseObjectSlotIndex::newUnchecked(base, index) } );
        assume baseObjectSlotIndex == BaseValueIndex::new(base, index, 0_u32);
        baseObjectSlotIndex
    }

    unsafe fn newUnchecked(base: Reg, index: Reg) -> BaseObjectSlotIndex;
}

enum ABIFunction {
    EqualStringsHelperPure
}

impl ABIFunction {
    #[spec]
    fn call(function: ABIFunction) {
        if function == ABIFunction::EqualStringsHelperPure {
            let str1 = MASM::getString(Reg::Rcx);
            let str2 = MASM::getString(Reg::Rdx);

            ABIFunction::clobberVolatileRegs();

            let equal = equalStringsHelperPure(str1, str2);
            MASM::setBool(Reg::Rax, equal);
        } else {
            assert false;
        }
    }

    #[spec]
    fn clobberVolatileRegs();
}

ir MASM {
    // NOTE: Needs to be implemented to call the equivalent
    // op with string as argument.
    op AssumeUnreachable() {
        assert false;
    }

    op Assert(cond: Bool) {
        assert cond;
    }

    op AssertEqValue(valueReg: ValueReg, value: Value, scratchValueReg: ValueReg) {
        // #ifdef DEBUG
        MASM::setValue(scratchValueReg, value);
        assert MASM::getValue(valueReg) == value;
        // #endif
    }

    op Move(srcReg: Reg, dstReg: Reg) {
        MASM::setData(dstReg, MASM::getData(srcReg));
    }

    op Move32Bool(srcReg: Reg, dstReg: Reg) {
        MASM::setBool(dstReg, MASM::getBool(srcReg));
    }

    op Move32Int32(srcReg: Reg, dstReg: Reg) {
        MASM::setInt32(dstReg, MASM::getInt32(srcReg));
    }

    op Move32Int32Imm(srcInt32: Int32, dstReg: Reg) {
        MASM::setInt32(dstReg, srcInt32);
    }

    op MoveValue(srcValueReg: ValueReg, dstValueReg: ValueReg) {
        MASM::setValue(dstValueReg, MASM::getValue(srcValueReg));
    }

    op MoveValueImm(value: Value, dstValueReg: ValueReg) {
        MASM::setValue(dstValueReg, value);
    }

    op MovePtrBoolImmWord(b: Bool, dstReg: Reg) {
        MASM::setBool(dstReg, b);
    }

    op MoveDouble(srcReg: FloatReg, dstReg: FloatReg) {
        MASM::setDouble(dstReg, MASM::getDouble(srcReg));
    }

    op MovePtrImmGCPtrObject(object: Object, dstReg: Reg) {
        MASM::setObject(dstReg, object);
    }

    op Cmp32Move32(condition: Condition, lhsReg: Reg, rhsReg: Reg, srcReg: Reg, dstReg: Reg) {
        assert (condition == Condition::GreaterThan || condition == Condition::LessThan);

        let lhsInt32 = MASM::getInt32(lhsReg);
        let rhsInt32 = MASM::getInt32(rhsReg);
        let srcInt32 = MASM::getInt32(srcReg);

        if condition == Condition::GreaterThan && lhsInt32 > rhsInt32 {
            MASM::setInt32(dstReg, srcInt32);
        } else if condition == Condition::LessThan && lhsInt32 < rhsInt32 {
            MASM::setInt32(dstReg, srcInt32);
        }
    }

    op StoreBool(bool: Bool, reg: Reg) {
        MASM::setBool(reg, bool);
    }

    op Jump(label target: MASM) {
        goto target;
    }

    op Load32Address(address: Address, dstReg: Reg) {
        let data = RegData::readData(MASM::getData(address.base), address.offset);
        let value = RegData::toUnboxedValue(data);
        let int32 = Value::toInt32(value);
        MASM::setInt32(dstReg, int32);
    }

    op LoadTypedOrValueAddress(address: Address, dstReg: TypedOrValueReg) {
        let data = RegData::readData(MASM::getData(address.base), address.offset);
        let value = RegData::toValue(data);

        if TypedOrValueReg::hasValue(dstReg) {
            MASM::setValue(TypedOrValueReg::toValueReg(dstReg), value);
        } else {
            assert TypedOrValueReg::hasTyped(dstReg);
            MASM::loadUnboxedValue(value, TypedOrValueReg::type(dstReg),
                TypedOrValueReg::toTypedReg(dstReg));
        }
    }

    op LoadTypedOrValueBaseObjectElementIndex(index: BaseObjectElementIndex, dstReg: TypedOrValueReg) {
        let data = RegData::readData(MASM::getData(index.base), BaseIndex::getOffset(index));
        let value = RegData::toValue(data);

        if TypedOrValueReg::hasValue(dstReg) {
            MASM::setValue(TypedOrValueReg::toValueReg(dstReg), value);
        } else {
            assert TypedOrValueReg::hasTyped(dstReg);
            MASM::loadUnboxedValue(value, TypedOrValueReg::type(dstReg),
                TypedOrValueReg::toTypedReg(dstReg));
        }
    }

    op LoadValueBaseObjectElementIndex(index: BaseObjectElementIndex, dstReg: ValueReg) {
        let data = RegData::readData(MASM::getData(index.base), BaseIndex::getOffset(index));
        let value = RegData::toValue(data);
        MASM::setValue(dstReg, value);
    }

    op LoadPtrAddress(address: Address, dstReg: Reg) {
        let data = RegData::readData(MASM::getData(address.base), address.offset);
        MASM::setData(dstReg, data);
    }

    op PushRegsInMask(set: LiveRegSet) {
        MASM::pushRegsInMask(set);
    }

    op PopRegsInMaskIgnore(set: LiveRegSet, ignore: LiveRegSet) {
        MASM::popRegsInMaskIgnore(set, ignore);
    }

    op PushFloatReg(floatReg: FloatReg) {
        MASM::stackPushFloatReg(floatReg);
    }

    op PopFloatReg(floatReg: FloatReg) {
        MASM::stackPopFloatReg(floatReg);
    }

    op GuardSpecificAtom(
        strReg: Reg, atom: Atom, scratchReg: Reg, volatileRegs: LiveRegSet, label fail: MASM
    ) {
        let str = MASM::getString(strReg);
        if str == atom {
            return;
        }

        if String::isAtom(str) {
            goto fail;
        }

        if String::length(str) != String::length(atom) {
            goto fail;
        }

        MASM::pushRegsInMask(volatileRegs);

        MASM::setString(scratchReg, atom);
        MASM::setString(Reg::Rcx, MASM::getString(scratchReg));
        MASM::setString(Reg::Rdx, str);

        ABIFunction::call(ABIFunction::EqualStringsHelperPure);
        MASM::setBool(scratchReg, MASM::getBool(Reg::Rax));

        assert !LiveRegSet::containsReg(volatileRegs, scratchReg);
        MASM::popRegsInMask(volatileRegs);

        let result = MASM::getBool(scratchReg);
        if !result {
            goto fail;
        }
    }

    op TagValue(valTy: JSValueType, payload: Reg, dest: ValueReg) {
        // TODO: Don't have getters/setters for other types yet
        if valTy == JSValueType::Object {
            let o = MASM::getObject(payload);
            let val = Value::fromObject(o);
            MASM::setValue(dest, val);
        } else if valTy == JSValueType::Int32 {
            let i = MASM::getInt32(payload);
            let val = Value::fromInt32(i);
            MASM::setValue(dest, val);
        } else if valTy == JSValueType::Bool {
            let b = MASM::getBool(payload);
            let val = Value::fromBool(b);
            MASM::setValue(dest, val);
        } else if valTy == JSValueType::String {
            let s = MASM::getString(payload);
            let val = Value::fromString(s);
            MASM::setValue(dest, val);
        } else if valTy == JSValueType::Symbol {
            let s = MASM::getSymbol(payload);
            let val = Value::fromSymbol(s);
            MASM::setValue(dest, val);
        } else if valTy == JSValueType::BigInt {
            let b = MASM::getBigInt(payload);
            let val = Value::fromBigInt(b);
            MASM::setValue(dest, val);
        } else {
            assert false;
        }
    }

    op EnsureDouble(srcReg: ValueReg, destReg: FloatReg, label failure: MASM) {
        let value = MASM::getValue(srcReg);
        let valTy = Value::typeOf(value);

        if valTy == ValueType::Double {
            let double = Value::toDouble(value);
            MASM::setDouble(destReg, double);
        } else if valTy == ValueType::Int32 {
            let int32 = Value::toInt32(value);
            let double = Float64::fromInt32(int32);
            MASM::setDouble(destReg, double);
        } else {
            goto failure;
        }
    }

    op BoxDouble(srcReg: FloatReg, valueReg: ValueReg, scratchReg: FloatReg) {
        let double = MASM::getDouble(srcReg);
        let value = Value::fromDouble(double);
        MASM::setValue(valueReg, value);
    }

    op UnboxInt32(valueReg: ValueReg, int32Reg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setInt32(int32Reg, Value::toInt32(value));
    }

    op UnboxObject(valueReg: ValueReg, objectReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setObject(objectReg, Value::toObject(value));
    }

    op FallibleUnboxObject(valueReg: ValueReg, objectReg: Reg, label failure: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsObject = Value::isObject(value);

        if !valueIsObject {
            goto failure;
        }

        let object = Value::toObject(value);
        MASM::setObject(objectReg, object);
    }

    op FallibleUnboxBoolean(valueReg: ValueReg, boolReg: Reg, label failure: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsBool = Value::isBool(value);

        if !valueIsBool {
            goto failure;
        }

        let bool = Value::toBool(value);
        MASM::setBool(boolReg, bool);
    }

    op UnboxString(valueReg: ValueReg, stringReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setString(stringReg, Value::toString(value));
    }

    op UnboxSymbol(valueReg: ValueReg, symbolReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setSymbol(symbolReg, Value::toSymbol(value));
    }

    op UnboxBigInt(valueReg: ValueReg, bigIntReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setBigInt(bigIntReg, Value::toBigInt(value));
    }

    op UnboxNonDouble(valueReg: ValueReg, dstReg: Reg, valTy: JSValueType) {
        let value = MASM::getValue(valueReg);
        MASM::unboxNonDouble(value, dstReg, valTy);
    }

    op UnboxDouble(valueReg: ValueReg, floatReg: FloatReg) {
        let value = MASM::getValue(valueReg);
        let double = Value::toDouble(value);
        MASM::setDouble(floatReg, double);
    }

    // NOTE: This Op needs to be implemented as a Phantom Op on the
    // C++ side since Firefox implicitly reinterprets booleans
    // as int32 within registers.
    op CastBoolToInt32(int32Reg: Reg) {
        let bool = MASM::getBool(int32Reg);
        if bool {
            MASM::setInt32(int32Reg, 1_i32);
        } else {
            MASM::setInt32(int32Reg, 0_i32);
        }
    }

    op ConvertInt32ValueToDouble(valueReg: ValueReg) {
        let value = MASM::getValue(valueReg);

        if !Value::isInt32(value) {
            return;
        }

        let int32 = Value::toInt32(value);
        let double = Float64::fromInt32(int32);
        MASM::setValue(valueReg, Value::fromDouble(double));
    }

    op ConvertDoubleToInt32(srcReg: FloatReg, destReg: Reg, label failure: MASM, negativeZeroCheck: Bool) {
        let double = MASM::getDouble(srcReg);

        if negativeZeroCheck && Float64::isNegativeZero(double) {
            goto failure;
        }

        let int32 = Float64::toInt32(double);
        let doubleTrunc = Float64::fromInt32(int32);

        MASM::setDouble(FloatReg::doubleScratchReg(), doubleTrunc);

        if Float64::isNaN(double) || Float64::isNaN(doubleTrunc) || double != doubleTrunc {
            goto failure;
        }


        MASM::setInt32(destReg, int32);
    }

    op ConvertUInt32ToDouble(srcReg: Reg, destReg: FloatReg) {
        let uint32 = MASM::getInt32(srcReg) as UInt32;

        let double = Float64::fromUInt32(uint32);

        MASM::setDouble(destReg, double);
    }

    op SpectreBoundsCheck32Address(
        indexReg: Reg,
        length: Address,
        maybeScratch: Reg,
        label failure: MASM
    ) {
        assert indexReg != length.base;
        assert length.base != maybeScratch;
        assert indexReg != maybeScratch;

        let index = MASM::getInt32(indexReg) as UInt32;
        let data = RegData::readData(MASM::getData(length.base), length.offset);
        let length = Value::toInt32(RegData::toUnboxedValue(data)) as UInt32;

        if index >= length {
            goto failure;
        }
    }

    op BranchTestNumber(
        condition: Condition,
        valueReg: ValueReg,
        label branch: MASM,
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);

        let valueIsNumber = Value::isInt32(value) || Value::isDouble(value);

        if condition == Condition::Equal && valueIsNumber {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsNumber {
            goto branch;
        }
    }

    op BranchTestNumberTag(
        condition: Condition,
        tagReg: Reg,
        label branch: MASM,
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let tag = MASM::getValueTag(tagReg);

        let valueIsNumber = tag == ValueType::Int32 || tag == ValueType::Double;

        if condition == Condition::Equal && valueIsNumber {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsNumber {
            goto branch;
        }
    }

    op BranchTestDouble(
        condition: Condition,
        valueReg: ValueReg,
        label branch: MASM,
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);

        let valueIsDouble = Value::isDouble(value);

        if condition == Condition::Equal && valueIsDouble {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsDouble {
            goto branch;
        }
    }

    op BranchTestDoubleTag(
        condition: Condition,
        tagReg: Reg,
        label branch: MASM,
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let tag = MASM::getValueTag(tagReg);

        let tagIsDouble = tag == ValueType::Double;

        if condition == Condition::Equal && tagIsDouble {
            goto branch;
        } else if condition == Condition::NotEqual && !tagIsDouble {
            goto branch;
        }
    }

    op BranchObject(
        condition: Condition,
        lhsReg: Reg,
        rhsReg: Reg,
        label branch: MASM,
    ) {
        let lhs = MASM::getObject(lhsReg);
        let rhs = MASM::getObject(rhsReg);
        let isEqual = lhs == rhs;

        if condition == Condition::Equal {
            if isEqual {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !isEqual {
                goto branch;
            }
        }
    }

    op BranchObjectProto(
        condition: Condition,
        protoReg: Reg,
        objectReg: Reg,
        label branch: MASM,
    ) {
        let proto = MASM::getTaggedProto(protoReg);
        let object = MASM::getObject(objectReg);
        let isEqual = TaggedProto::isObject(proto) && TaggedProto::toObject(proto) == object;

        if condition == Condition::Equal {
            if isEqual {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !isEqual {
                goto branch;
            }
        }
    }

    op ConvertInt32ToDouble(srcReg: Reg, destReg: FloatReg) {
        let int32 = MASM::getInt32(srcReg);
        let double = Float64::fromInt32(int32);
        MASM::setDouble(destReg, double);
    }

    op BranchTestInt32(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsInt32 = Value::isInt32(value);

        if condition == Condition::Equal && valueIsInt32 {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsInt32 {
            goto branch;
        }
    }

    op BranchTestInt32Tag(condition: Condition, tagReg: Reg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let tag = MASM::getValueTag(tagReg);
        let tagIsInt32 = tag == ValueType::Int32;

        if condition == Condition::Equal && tagIsInt32 {
            goto branch;
        } else if condition == Condition::NotEqual && !tagIsInt32 {
            goto branch;
        }
    }

    op BranchTestInt32Truthy(truthy: Bool, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let int32 = Value::toInt32(value);

        if (!truthy && int32 == 0_i32) || (truthy && int32 != 0_i32) {
            goto branch;
        }
    }

    op BranchTestBoolean(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsBool = Value::isBool(value);

        if condition == Condition::Equal && valueIsBool {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsBool {
            goto branch;
        }
    }

    op BranchTestString(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsString = Value::isString(value);

        if condition == Condition::Equal && valueIsString {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsString {
            goto branch;
        }
    }

    op BranchTestSymbol(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsSymbol = Value::isSymbol(value);

        if condition == Condition::Equal && valueIsSymbol {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsSymbol {
            goto branch;
        }
    }

    op BranchTestBigInt(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsBigInt = Value::isBigInt(value);

        if condition == Condition::Equal && valueIsBigInt {
            goto branch;
        } else if condition == Condition::NotEqual && !valueIsBigInt {
            goto branch;
        }
    }

    op BranchTestObject(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let value = MASM::getValue(valueReg);
        let valueIsObject = Value::isObject(value);

        if condition == Condition::Equal && valueIsObject {
            goto branch;
        }

        if condition == Condition::NotEqual && !valueIsObject {
            goto branch;
        }
    }

    op BranchTestObjectTag(condition: Condition, tagReg: Reg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        let tag = MASM::getValueTag(tagReg);
        let valueIsObject = tag == ValueType::Object;

        if condition == Condition::Equal && valueIsObject {
            goto branch;
        }

        if condition == Condition::NotEqual && !valueIsObject {
            goto branch;
        }
    }

    op BranchTestValue(cond: Condition, lhs: BaseIndex, rhs: ValueReg, label branch: MASM) {
        assert cond == Condition::Equal || cond == Condition::NotEqual;

        let lhsBaseData = MASM::getData(lhs.base);
        let lhsOffset = BaseIndex::getOffset(lhs);
        let lhsData = RegData::readData(lhsBaseData, lhsOffset);
        let lhsValue = RegData::toValue(lhsData);

        let rhsValue = MASM::getValue(rhs);

        if cond == Condition::Equal && lhsValue == rhsValue {
            goto branch;
        } else if cond == Condition::NotEqual && lhsValue != rhsValue {
            goto branch;
        }
    }

    op BranchTestNullProto(reg: Reg, label branch: MASM) {
        let proto = MASM::getTaggedProto(reg);
        if TaggedProto::isNull(proto) {
            goto branch;
        }
    }

    op BranchTestLazyProto(reg: Reg, label branch: MASM) {
        let proto = MASM::getTaggedProto(reg);
        if TaggedProto::isLazy(proto) {
            goto branch;
        }
    }

    op BranchTestObjectProto(reg: Reg, label branch: MASM) {
        let proto = MASM::getTaggedProto(reg);
        if TaggedProto::isObject(proto) {
            goto branch;
        }
    }

    op BranchTestNull(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let value = MASM::getValue(valueReg);
        let valueIsNull = Value::isNull(value);

        if condition == Condition::Equal && valueIsNull {
            goto branch;
        }

        if condition == Condition::NotEqual && !valueIsNull {
            goto branch;
        }
    }

    op BranchTestNullTag(condition: Condition, tagReg: Reg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let tag = MASM::getValueTag(tagReg);
        let valueIsNull = tag == ValueType::Null;

        if condition == Condition::Equal && valueIsNull {
            goto branch;
        }

        if condition == Condition::NotEqual && !valueIsNull {
            goto branch;
        }
    }

    op TestNullSet(condition: Condition, valueReg: ValueReg, destReg: Reg) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let value = MASM::getValue(valueReg);
        let valueIsNull = Value::isNull(value);

        if ((condition == Condition::Equal && valueIsNull) ||
                (condition == Condition::NotEqual && !valueIsNull)) {
            MASM::setBool(destReg, true);
        } else {
            MASM::setBool(destReg, false);
        }
    }

    op BranchTestUndefined(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let value = MASM::getValue(valueReg);
        let valueIsUndefined = Value::isUndefined(value);

        if condition == Condition::Equal && valueIsUndefined{
            goto branch;
        }

        if condition == Condition::NotEqual && !valueIsUndefined {
            goto branch;
        }
    }

    op BranchTestUndefinedTag(condition: Condition, tagReg: Reg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let tag = MASM::getValueTag(tagReg);
        let valueIsUndefined = tag == ValueType::Undefined;

        if condition == Condition::Equal && valueIsUndefined{
            goto branch;
        }

        if condition == Condition::NotEqual && !valueIsUndefined {
            goto branch;
        }
    }

    op BranchIfObjectEmulatesUndefined(
        objReg: Reg, scratchReg: Reg, label slowCheck: MASM, label branch: MASM
    ) {
        let object = MASM::getObject(objReg);
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        MASM::setData(scratchReg, RegData::fromClass(class));

        if Class::isProxyObject(class) {
            goto slowCheck;
        }

        if Class::emulatesUndefined(class) {
            goto branch;
        }
    }

    op TestUndefinedSet(condition: Condition, valueReg: ValueReg, destReg: Reg) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let value = MASM::getValue(valueReg);
        let valueIsUndefined = Value::isUndefined(value);

        if ((condition == Condition::Equal && valueIsUndefined) ||
                (condition == Condition::NotEqual && !valueIsUndefined)) {
            MASM::setBool(destReg, true);
        } else {
            MASM::setBool(destReg, false);
        }
    }

    op BranchTestMagic(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let value = MASM::getValue(valueReg);
        let valueIsMagic = Value::isMagic(value);

        if condition == Condition::Equal && valueIsMagic {
            goto branch;
        }

        if condition == Condition::NotEqual && !valueIsMagic {
            goto branch;
        }
    }

    op BranchTestMagicBaseObjectElementIndex(
        condition: Condition,
        index: BaseObjectElementIndex,
        label branch: MASM,
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let data = RegData::readData(MASM::getData(index.base), BaseIndex::getOffset(index));
        let value = RegData::toValue(data);
        let valueIsMagic = Value::isMagic(value);

        if condition == Condition::Equal && valueIsMagic {
            goto branch;
        }

        if condition == Condition::NotEqual && !valueIsMagic {
            goto branch;
        }
    }

    op BranchTestObjectShape(
        condition: Condition, objectReg: Reg, shape: Shape, scratchReg: Reg, spectreRegToZero: Reg,
        label branch: MASM
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        assert objectReg != scratchReg;
        assert spectreRegToZero != scratchReg;

        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        MASM::setInt32(scratchReg, 0_i32);

        if condition == Condition::Equal && objectHasShape {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasShape {
            goto branch;
        }
    }

    op BranchTestObjectShapeNoSpectreMitigations(
        condition: Condition, objectReg: Reg, shape: Shape, label branch: MASM
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        if condition == Condition::Equal && objectHasShape {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasShape {
            goto branch;
        }
    }

    op BranchTestObjClass(
        condition: Condition, objectReg: Reg, class: Class, scratchReg: Reg, spectreRegToZero: Reg,
        label branch: MASM
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;
        assert scratchReg != spectreRegToZero;

        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        MASM::setData(scratchReg, RegData::fromClass(class));

        let objectHasClass = Shape::classOf(shape) == class;

        if condition == Condition::Equal && objectHasClass {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasClass {
            goto branch;
        }

        MASM::setInt32(scratchReg, 0_i32);
    }

    op BranchTestObjClassNoSpectreMitigations(
        condition: Condition, objectReg: Reg, class: Class, scratchReg: Reg, label branch: MASM
    ) {
        assert condition == Condition::Equal || condition == Condition::NotEqual;

        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        MASM::setData(scratchReg, RegData::fromClass(class));

        let objectHasClass = Shape::classOf(shape) == class;

        if condition == Condition::Equal && objectHasClass {
            goto branch;
        } else if condition == Condition::NotEqual && !objectHasClass {
            goto branch;
        }
    }

    op BranchIfNonNativeObj(objectReg: Reg, scratchReg: Reg, label branch: MASM) {
        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        MASM::setData(scratchReg, RegData::fromClass(class));
        let objectIsNative = Class::isNativeObject(class);

        if !objectIsNative {
            goto branch;
        }
    }

    op BranchTestObjectIsProxy(proxy: Bool, objectReg: Reg, scratchReg: Reg, label branch: MASM) {
        let object = MASM::getObject(objectReg);
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        MASM::setData(scratchReg, RegData::fromClass(class));
        let objectIsProxy = Class::isProxyObject(class);

        if !proxy && !objectIsProxy {
            goto branch;
        } else if proxy && objectIsProxy {
            goto branch;
        }
    }

    op Branch32(condition: Condition, lhsReg: Reg, rhsReg: Reg, label branch: MASM) {
        assert (
            condition == Condition::Equal || condition == Condition::NotEqual ||
            condition == Condition::GreaterThan || condition == Condition::LessThan ||
            condition == Condition::GreaterThanOrEqual || condition == Condition::LessThanOrEqual ||
            condition == Condition::Above || condition == Condition::Below ||
            condition == Condition::AboveOrEqual || condition == Condition::BelowOrEqual

        );

        let lhsInt32 = MASM::getInt32(lhsReg);
        let rhsInt32 = MASM::getInt32(rhsReg);

        let lhsUInt32 = lhsInt32 as UInt32;
        let rhsUInt32 = rhsInt32 as UInt32;

        if condition == Condition::Equal && lhsInt32 == rhsInt32 {
            goto branch;
        } else if condition == Condition::NotEqual && lhsInt32 != rhsInt32 {
            goto branch;
        } else if condition == Condition::GreaterThan && lhsInt32 > rhsInt32 {
            goto branch;
        } else if condition == Condition::LessThan && lhsInt32 < rhsInt32 {
            goto branch;
        } else if condition == Condition::GreaterThanOrEqual && lhsInt32 >= rhsInt32 {
            goto branch;
        } else if condition == Condition::LessThanOrEqual && lhsInt32 <= rhsInt32 {
            goto branch;
        } else if condition == Condition::Above && lhsUInt32 > rhsUInt32 {
            goto branch;
        } else if condition == Condition::Below && lhsUInt32 < rhsUInt32 {
            goto branch;
        } else if condition == Condition::AboveOrEqual && lhsUInt32 >= rhsUInt32 {
            goto branch;
        } else if condition == Condition::BelowOrEqual && lhsUInt32 <= rhsUInt32 {
            goto branch;
        }
    }

    op Branch32Tag(condition: Condition, lhsReg: Reg, rhsReg: Reg, label branch: MASM) {
        assert (
            condition == Condition::Equal || condition == Condition::NotEqual
        );

        let lhsTag = MASM::getValueTag(lhsReg);
        let rhsTag = MASM::getValueTag(rhsReg);

        if condition == Condition::Equal && lhsTag == rhsTag {
            goto branch;
        } else if condition == Condition::NotEqual && lhsTag != rhsTag {
            goto branch;
        }
    }

    // NOTE: This Op needs to be implemented on the C++ to delegate to the
    // appropriate overload of Branch32Imm since Cachet doesn't have overloading.
    op Branch32Imm(condition: Condition, lhsReg: Reg, rhsInt32: Int32, label branch: MASM) {
        assert (
            condition == Condition::Equal ||
            condition == Condition::NotEqual ||
            condition == Condition::LessThan
        );

        let lhsInt32 = MASM::getInt32(lhsReg);

        if condition == Condition::Equal && lhsInt32 == rhsInt32 {
            goto branch;
        } else if condition == Condition::NotEqual && lhsInt32 != rhsInt32 {
            goto branch;
        } else if condition == Condition::LessThan && lhsInt32 < rhsInt32 {
            goto branch;
        }
    }

    op Branch32AddressImm32(
        condition: Condition, address: Address, rhsInt32: Int32, label branch:MASM
    ) {
        assert (
            condition == Condition::Equal ||
            condition == Condition::NotEqual ||
            condition == Condition::LessThan
        );

        let data = RegData::readData(MASM::getData(address.base), address.offset);
        let lhsInt32 = Value::toInt32(RegData::toUnboxedValue(data));

        if condition == Condition::Equal && lhsInt32 == rhsInt32 {
            goto branch;
        } else if condition == Condition::NotEqual && lhsInt32 != rhsInt32 {
            goto branch;
        } else if condition == Condition::LessThan && lhsInt32 < rhsInt32 {
            goto branch;
        }
    }

    op BranchTest32(condition: Condition, lhsReg: Reg, rhsReg: Reg, label branch: MASM) {
        let lhsInt32 = MASM::getInt32(lhsReg);
        let rhsInt32 = MASM::getInt32(rhsReg);

        let result = lhsInt32 & rhsInt32;

        assert (
            condition == Condition::Zero ||
            condition == Condition::NonZero ||
            condition == Condition::Signed ||
            condition == Condition::NotSigned
        );

        if condition == Condition::Zero && result == 0_i32 {
            goto branch;
        } else if condition == Condition::NonZero && result != 0_i32 {
            goto branch;
        } else if condition == Condition::Signed && result < 0_i32 {
            goto branch;
        } else if condition == Condition::NotSigned && result > 0_i32 {
            goto branch;
        }
    }

    op BranchTest32Imm(condition: Condition, lhsReg: Reg, rhsInt32: Int32, label branch: MASM) {
        let lhsInt32 = MASM::getInt32(lhsReg);

        let result = lhsInt32 & rhsInt32;

        assert (
            condition == Condition::Zero ||
            condition == Condition::NonZero ||
            condition == Condition::Signed ||
            condition == Condition::NotSigned
        );

        if condition == Condition::Zero && result == 0_i32 {
            goto branch;
        } else if condition == Condition::NonZero && result != 0_i32 {
            goto branch;
        } else if condition == Condition::Signed && result < 0_i32 {
            goto branch;
        } else if condition == Condition::NotSigned && result > 0_i32 {
            goto branch;
        }
    }

    op BranchAdd32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
        let lhsInt32 = MASM::getInt32(srcReg);
        let rhsInt32 = MASM::getInt32(dstReg);

        assert condition == Condition::Overflow;
        let mut sum = 0_i32;
        if !Int32::checkedAdd(lhsInt32, rhsInt32, out sum) {
            goto branch;
        }

        MASM::setInt32(dstReg, sum);
    }

    op BranchAdd32Imm(condition: Condition, lhsInt32: Int32, dstReg: Reg, label branch: MASM) {
        let rhsInt32 = MASM::getInt32(dstReg);

        let result = lhsInt32 + rhsInt32;

        assert condition == Condition::Overflow;
        if lhsInt32 > 0_i32 && rhsInt32 > 0_i32 && result < 0_i32 {
            goto branch;
        }

        if lhsInt32 < 0_i32 && rhsInt32 < 0_i32 && result > 0_i32 {
            goto branch;
        }

        MASM::setInt32(dstReg, result);
    }

    op BranchSub32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
        let lhsInt32 = MASM::getInt32(dstReg);
        let rhsInt32 = MASM::getInt32(srcReg);

        let result = lhsInt32 - rhsInt32;

        assert condition == Condition::Overflow;

        let rhsInt32Neg = -rhsInt32;
        let minInt32 = 1_i32 << 31_i32; // Do it this way until negative literals are a thing

        if rhsInt32 == minInt32 && lhsInt32 >= 0_i32 {
            goto branch;
        } else if lhsInt32 > 0_i32 && rhsInt32 < 0_i32 && result < 0_i32 {
            goto branch;
        }

        if lhsInt32 < 0_i32 && rhsInt32 > 0_i32 && result > 0_i32 {
            goto branch;
        }

        MASM::setInt32(dstReg, result);
    }

    op BranchSub32Imm(condition: Condition, rhsInt32: Int32, dstReg: Reg, label branch: MASM) {
        let lhsInt32 = MASM::getInt32(dstReg);

        let result = lhsInt32 - rhsInt32;

        assert condition == Condition::Overflow;

        let rhsInt32Neg = -rhsInt32;
        let minInt32 = 1_i32 << 31_i32; // Do it this way until negative literals are a thing

        if rhsInt32 == minInt32 && lhsInt32 >= 0_i32 {
            goto branch;
        } else if lhsInt32 > 0_i32 && rhsInt32 < 0_i32 && result < 0_i32 {
            goto branch;
        }

        if lhsInt32 < 0_i32 && rhsInt32 > 0_i32 && result > 0_i32 {
            goto branch;
        }

        MASM::setInt32(dstReg, result);
    }

    op BranchMul32(condition: Condition, srcReg: Reg, dstReg: Reg, label branch: MASM) {
        let lhsInt32 = MASM::getInt32(dstReg);
        let rhsInt32 = MASM::getInt32(srcReg);

        let result = lhsInt32 * rhsInt32;

        assert condition == Condition::Overflow;

        let resultWide = (lhsInt32 as Int64) * (rhsInt32 as Int64);
        if (result as Int64) != resultWide {
            goto branch;
        }

        MASM::setInt32(dstReg, result);
    }

    op FlexibleDivMod32(rhsReg: Reg, lhsOutputReg: Reg,
                        remOutputReg: Reg, isUnsigned: Bool,
                        volatileRegs: LiveRegSet) {
        assert lhsOutputReg != rhsReg;
        assert lhsOutputReg != remOutputReg;

        let lhsInt32 = MASM::getInt32(lhsOutputReg);
        let rhsInt32 = MASM::getInt32(rhsReg);

        if isUnsigned {
            let lhsUInt64 = (lhsInt32 as UInt32) as UInt64;
            let rhsUInt32 = rhsInt32 as UInt32;

            let quotient = lhsUInt64 / rhsUInt32;
            let remainder = lhsUInt64 % rhsUInt32;

            MASM::setInt32(lhsOutputReg, quotient as Int32);
            MASM::setInt32(remOutputReg, remainder as Int32);
        } else {
            let lhsInt64 = lhsInt32 as Int64;

            let quotient = lhsInt64 / rhsInt32;
            let remainder = lhsInt64 % rhsInt32;

            MASM::setInt32(lhsOutputReg, quotient as Int32);
            MASM::setInt32(remOutputReg, remainder as Int32);
        }
    }

    op FlexibleRemainder32(
        rhsReg: Reg, lhsOutputReg: Reg, isUnsigned: Bool,
        volatileLiveRegs: LiveRegSet) {

        let lhsInt32 = MASM::getInt32(lhsOutputReg);
        let rhsInt32 = MASM::getInt32(rhsReg);

        if isUnsigned {
            let lhsUInt64 = (lhsInt32 as UInt32) as UInt64;
            let rhsUInt32 = rhsInt32 as UInt32;

            let remainder = lhsUInt64 % rhsUInt32;
            MASM::setInt32(lhsOutputReg, remainder as Int32);
        } else {
            let lhsInt64 = lhsInt32 as Int64;

            let remainder = lhsInt64 % rhsInt32;
            MASM::setInt32(lhsOutputReg, remainder as Int32);
        }
    }

    op Neg32(valueReg: Reg) {
        let valueInt32 = MASM::getInt32(valueReg);
        let result = -valueInt32;

        MASM::setInt32(valueReg, result);
    }

    op Not32(valueReg: Reg) {
        let valueInt32 = MASM::getInt32(valueReg);
        let result = ~valueInt32;

        MASM::setInt32(valueReg, result);
    }

    op Or32(srcReg: Reg, dstReg: Reg) {
        let lhsInt32 = MASM::getInt32(srcReg);
        let rhsInt32 = MASM::getInt32(dstReg);

        let result = lhsInt32 | rhsInt32;

        MASM::setInt32(dstReg, result);
    }

    op Xor32(srcReg: Reg, dstReg: Reg) {
        let lhsInt32 = MASM::getInt32(srcReg);
        let rhsInt32 = MASM::getInt32(dstReg);

        let result = lhsInt32 ^ rhsInt32;

        MASM::setInt32(dstReg, result);
    }

    op And32(srcReg: Reg, dstReg: Reg) {
        let lhsInt32 = MASM::getInt32(srcReg);
        let rhsInt32 = MASM::getInt32(dstReg);

        let result = lhsInt32 & rhsInt32;

        MASM::setInt32(dstReg, result);
    }

    op FlexibleLshift32(shiftReg: Reg, srcDestReg: Reg) {
        let shiftInt32 = MASM::getInt32(shiftReg) & 31_i32;
        let srcInt32 = MASM::getInt32(srcDestReg);

        let result = srcInt32 << shiftInt32;

        MASM::setInt32(srcDestReg, result);
    }

    op FlexibleRshift32Arithmetic(shiftReg: Reg, srcDestReg: Reg) {
        let shiftInt32 = MASM::getInt32(shiftReg) & 31_i32;
        let srcInt32 = MASM::getInt32(srcDestReg);

        let result = srcInt32 >> shiftInt32;

        MASM::setInt32(srcDestReg, result);
    }

    op FlexibleRshift32(shiftReg: Reg, srcDestReg: Reg) {
        let shiftInt32 = MASM::getInt32(shiftReg) & 31_i32;
        let srcInt32 = MASM::getInt32(srcDestReg);

        let result = ((srcInt32 as UInt32) >> (shiftInt32 as UInt32)) as Int32;

        MASM::setInt32(srcDestReg, result);
    }

    op TestObjectSet(condition: Condition, valueReg: ValueReg, dstReg: Reg) {
        assert (condition == Condition::Equal || condition == Condition::NotEqual);

        let value = MASM::getValue(valueReg);
        let isObject = Value::isObject(value);

        MASM::setBool(dstReg, false);

        if condition == Condition::Equal && isObject {
            MASM::setBool(dstReg, true);
        } else if condition == Condition::NotEqual && !isObject {
            MASM::setBool(dstReg, true);
        }
    }

    op LoadArgumentsObjectLength(
        objectReg: Reg, outputReg: Reg, label failure: MASM
    ) {
        let obj = MASM::getObject(objectReg);
        let argObj = Object::toArgumentsObject(obj);
        let length = ArgumentsObject::getInitialLengthSlot(argObj);
        MASM::setInt32(outputReg, length as Int32);
        if ArgumentsObject::hasOverriddenLength(argObj) {
            goto failure;
        }
        MASM::setInt32(outputReg, ArgumentsObject::getInitialLength(argObj) as Int32);
    }

    op LoadArgumentsObjectElement(
        objReg: Reg, indexReg: Reg, output: ValueReg, tempReg: Reg, label failure: MASM,
    ) {
        let tempReg2 = ValueReg::scratchReg(output);

        let obj = MASM::getObject(objReg);
        let argObj = Object::toArgumentsObject(obj);
        let length = ArgumentsObject::getInitialLengthSlot(argObj);
        MASM::setInt32(tempReg, length as Int32);

        if ArgumentsObject::hasOverriddenElement(argObj) {
            goto failure;
        }

        length = ArgumentsObject::getInitialLength(argObj);
        MASM::setInt32(tempReg, length as Int32);

        let index = MASM::getInt32(indexReg) as UInt32;

        if index >= length {
            goto failure;
        }

        let argsData = ArgumentsObject::getArgumentsData(argObj);
        MASM::setData(tempReg, RegData::fromArgumentsData(argsData));

        let argValue = ArgumentsData::getArg(argsData, index as UInt32);
        if Value::isMagic(argValue) {
            goto failure;
        }

        MASM::setValue(output, argValue);
    }

    op LoadObjectProto(objectReg: Reg, protoReg: Reg) {
        let object = MASM::getObject(objectReg);

        let shape = Object::shapeOf(object);
        let baseShape = Shape::baseShapeOf(shape);
        let proto = BaseShape::protoOf(baseShape);

        MASM::setTaggedProto(protoReg, proto);
    }

    op UnboxObjectProto(protoReg: Reg) {
        // This is a no-op on the C++ side.
        let proto = MASM::getTaggedProto(protoReg);
        let object = TaggedProto::toObject(proto);
        MASM::setObject(protoReg, object);
    }

    op SplitTagForTest(valueReg: ValueReg, tagReg: Reg) {
        let value = MASM::getValue(valueReg);
        let tag = Value::typeOf(value);
        MASM::setValueTag(tagReg, tag);
    }

    fn extractTag(valueReg: ValueReg, scratchReg: Reg) emits MASM -> Reg {
        assert scratchReg != Reg::scratchReg();

        emit MASM::SplitTagForTest(valueReg, scratchReg);
        return scratchReg;
    }

    #[spec]
    fn loadUnboxedValue(value: Value, type: MIRType, dstReg: AnyReg) {
        if AnyReg::isFloat(dstReg) {
            MASM::loadInt32OrDouble(value, AnyReg::toFloatReg(dstReg));
        } else {
            MASM::unboxNonDouble(value, AnyReg::toReg(dstReg), JSValueType::fromMIRType(type));
        }
    }

    #[spec]
    fn loadInt32OrDouble(value: Value, dstReg: FloatReg) {
        if Value::isInt32(value) {
            let int32 = Value::toInt32(value);
            let double = Float64::fromInt32(int32);
            MASM::setDouble(dstReg, double);
        } else if Value::isDouble(value) {
            let double = Value::toDouble(value);
            MASM::setDouble(dstReg, double);
        }

        assert false;
    }

    #[spec]
    fn unboxNonDouble(value: Value, dstReg: Reg, valTy: JSValueType) {
        assert valTy != JSValueType::Double;

        if valTy == JSValueType::Object {
            let o = Value::toObject(value);
            MASM::setObject(dstReg, o);
        } else if valTy == JSValueType::Int32 {
            let i = Value::toInt32(value);
            MASM::setInt32(dstReg, i);
        } else if valTy == JSValueType::Bool {
            let b = Value::toBool(value);
            MASM::setBool(dstReg, b);
        } else if valTy == JSValueType::String {
            let s = Value::toString(value);
            MASM::setString(dstReg, s);
        } else if valTy == JSValueType::Symbol {
            let s = Value::toSymbol(value);
            MASM::setSymbol(dstReg, s);
        } else if valTy == JSValueType::BigInt {
            let b = Value::toBigInt(value);
            MASM::setBigInt(dstReg, b);
        } else {
            assert false;
        }
    }

    fn getValue(valueReg: ValueReg) -> Value;
    fn setValue(valueReg: ValueReg, value: Value);

    #[spec]
    fn getData(reg: Reg) -> RegData;
    #[spec]
    fn setData(reg: Reg, data: RegData);

    #[spec]
    fn getUnboxedValue(reg: Reg) -> Value {
        RegData::toUnboxedValue(MASM::getData(reg))
    }

    #[spec]
    fn setUnboxedValue(reg: Reg, value: Value) {
        MASM::setData(reg, RegData::fromUnboxedValue(value));
    }

    #[refined]
    fn getInt32(reg: Reg) -> Int32 {
        Value::toInt32(MASM::getUnboxedValue(reg))
    }

    #[refined]
    fn setInt32(reg: Reg, int32: Int32) {
        MASM::setUnboxedValue(reg, Value::fromInt32(int32));
    }

    #[refined]
    fn getBool(reg: Reg) -> Bool {
        Value::toBool(MASM::getUnboxedValue(reg))
    }

    #[refined]
    fn setBool(reg: Reg, bool: Bool) {
        MASM::setUnboxedValue(reg, Value::fromBool(bool));
    }

    #[refined]
    fn getObject(reg: Reg) -> Object {
        Value::toObject(MASM::getUnboxedValue(reg))
    }

    #[refined]
    fn setObject(reg: Reg, object: Object) {
        MASM::setUnboxedValue(reg, Value::fromObject(object));
    }

    #[refined]
    fn getString(reg: Reg) -> String {
        Value::toString(MASM::getUnboxedValue(reg))
    }

    #[refined]
    fn setString(reg: Reg, string: String) {
        MASM::setUnboxedValue(reg, Value::fromString(string));
    }

    #[refined]
    fn getSymbol(reg: Reg) -> Symbol {
        Value::toSymbol(MASM::getUnboxedValue(reg))
    }

    #[refined]
    fn setSymbol(reg: Reg, symbol: Symbol) {
        MASM::setUnboxedValue(reg, Value::fromSymbol(symbol));
    }

    #[refined]
    fn getBigInt(reg: Reg) -> BigInt {
        Value::toBigInt(MASM::getUnboxedValue(reg))
    }

    #[refined]
    fn setBigInt(reg: Reg, bigInt: BigInt) {
        MASM::setUnboxedValue(reg, Value::fromBigInt(bigInt));
    }

    #[refined]
    fn getValueTag(reg: Reg) -> ValueType {
        RegData::toValueType(MASM::getData(reg))
    }

    #[refined]
    fn setValueTag(reg: Reg, tag: ValueType) {
        MASM::setData(reg, RegData::fromValueType(tag));
    }

    #[refined]
    fn getTaggedProto(reg: Reg) -> TaggedProto {
        RegData::toTaggedProto(MASM::getData(reg))
    }

    #[refined]
    fn setTaggedProto(reg: Reg, proto: TaggedProto) {
        MASM::setData(reg, RegData::fromTaggedProto(proto));
    }

    #[refined]
    fn getStackIndex(reg: Reg) -> UInt64 {
        RegData::toStackIndex(MASM::getData(reg))
    }

    #[refined]
    fn setStackIndex(reg: Reg, stackIndex: UInt64) {
        MASM::setData(reg, RegData::fromStackIndex(stackIndex));
    }

    #[spec]
    fn getFloatData(phyReg: PhyFloatReg) -> FloatData;
    #[spec]
    fn setFloatData(phyReg: PhyFloatReg, data: FloatData);

    #[refined]
    fn getDouble(floatReg: FloatReg) -> Float64 {
        assert floatReg.type == FloatContentType::Double;
        FloatData::toDouble(MASM::getFloatData(floatReg.reg))
    }

    #[refined]
    fn setDouble(floatReg: FloatReg, double: Float64) {
        assert floatReg.type == FloatContentType::Double;
        MASM::setFloatData(floatReg.reg, FloatData::fromDouble(double));
    }

    #[spec]
    fn stackPush(stackData: StackData);
    #[spec]
    fn stackPop() -> StackData;

    #[spec]
    fn stackStore(idx: UInt64, stackData: StackData);
    #[spec]
    fn stackLoad(idx: UInt64) -> StackData;

    #[refined]
    fn stackPushReg(reg: Reg) {
        let regData = MASM::getData(reg);
        let stackData = StackData::fromRegData(regData);
        MASM::stackPush(stackData);
    }

    #[refined]
    fn stackPopReg(reg: Reg) {
        let stackData = MASM::stackPop();
        let regData = StackData::toRegData(stackData);
        MASM::setData(reg, regData);
    }

    #[refined]
    fn stackPushFloatReg(floatReg: FloatReg) {
        let floatData = MASM::getFloatData(floatReg.reg);
        let stackData = StackData::fromFloatData(floatData);
        MASM::stackPush(stackData);
    }

    #[refined]
    fn stackPopFloatReg(floatReg: FloatReg) {
        let stackData = MASM::stackPop();
        let floatData = StackData::toFloatData(stackData);
        MASM::setFloatData(floatReg.reg, floatData);
    }

    var mut hasPushedRegs: Bool;

    #[spec]
    fn setHasPushedRegs() {
        assert !MASM::hasPushedRegs;
        MASM::hasPushedRegs = true;
    }

    #[spec]
    fn unsetHasPushedRegs() {
        assert MASM::hasPushedRegs;
        MASM::hasPushedRegs = false;
    }

    #[spec]
    fn stackPushLiveGeneralReg(reg: Reg);
    #[spec]
    fn stackPopLiveGeneralReg(reg: Reg);

    #[spec]
    fn stackPushLiveFloatReg(floatReg: FloatReg);
    #[spec]
    fn stackPopLiveFloatReg(floatReg: FloatReg);

    #[refined]
    fn pushRegsInMask(set: LiveRegSet) {
        MASM::setHasPushedRegs();
        let gprs = LiveRegSet::gprs(set);
        let fpus = LiveRegSet::fpus(set);

        for reg in Reg desc {
            if GeneralRegSet::contains(gprs, reg) {
                MASM::stackPushLiveGeneralReg(reg);
            }
        }

        for phyReg in PhyFloatReg desc {
            let singleReg = FloatReg::new(phyReg, FloatContentType::Single);
            let doubleReg = FloatReg::new(phyReg, FloatContentType::Double);
            let simdReg = FloatReg::new(phyReg, FloatContentType::Simd128);

            if FloatRegSet::contains(fpus, simdReg) {
                MASM::stackPushLiveFloatReg(simdReg);
            } else if FloatRegSet::contains(fpus, doubleReg) {
                MASM::stackPushLiveFloatReg(doubleReg);
            } else if FloatRegSet::contains(fpus, singleReg) {
                MASM::stackPushLiveFloatReg(singleReg);
            }
        }
    }

    #[refined]
    fn popRegsInMaskIgnore(set: LiveRegSet, ignore: LiveRegSet) {
        let fpus = FloatRegSet::reducedForPush(LiveRegSet::fpus(set));
        let gprs = LiveRegSet::gprs(set);

        let fpusIgnore = LiveRegSet::fpus(ignore);
        let fpusPop = FloatRegSet::difference(fpus, fpusIgnore);

        for phyReg in PhyFloatReg desc {
            let singleReg = FloatReg::new(phyReg, FloatContentType::Single);
            let doubleReg = FloatReg::new(phyReg, FloatContentType::Double);
            let simdReg = FloatReg::new(phyReg, FloatContentType::Simd128);

            if FloatRegSet::contains(fpusPop, simdReg) {
                MASM::stackPopLiveFloatReg(simdReg);
            } else if FloatRegSet::contains(fpusPop, doubleReg) {
                MASM::stackPopLiveFloatReg(doubleReg);
            } else if FloatRegSet::contains(fpusPop, singleReg) {
                MASM::stackPopLiveFloatReg(singleReg);
            }
        }

        let gprsIgnore = LiveRegSet::gprs(ignore);
        let gprsPop = GeneralRegSet::difference(gprs, gprsIgnore);

        for reg in Reg desc {
            if GeneralRegSet::contains(gprsPop, reg) {
                MASM::stackPopLiveGeneralReg(reg);
            }
        }

        MASM::unsetHasPushedRegs();
    }

    #[refined]
    fn popRegsInMask(set: LiveRegSet) {
        let ignore = LiveRegSet::empty();
        MASM::popRegsInMaskIgnore(set, ignore);
    }
}

//impl MASM {
    //spec var mut regs: Map<Reg, Value>;
    //spec var mut valueRegs: Map<ValueReg, Value>;

    //fn getValue(valueReg: ValueReg) -> Value;

    //refine fn getValue(valueReg: ValueReg) -> Value {
        //Map::get(MASM::valueRegs, valueReg)
    //}

    //fn setValue(valueReg: ValueReg, value: Value);

    //refine fn setValue(valueReg: ValueReg, value: Value) {
        //MASM::valueRegs = Map::set(MASM::valueRegs, valueReg, value);
    //}

    //spec fn getUnboxedValue(reg: Reg) -> Value {
        //Map::get(MASM::regs, reg)
    //}

    //fn setUnboxedValue(reg: Reg, value: Value);

    //refine fn setUnboxedValue(reg: Reg, value: Value) {
        //MASM::regs = Map::set(MASM::regs, reg, value);
    //}

    //fn getInt32(reg: Reg) -> Int32;

    //refine fn getInt32(reg: Reg) -> Int32 {
        //Value::toInt32(MASM::getUnboxedValue(reg))
    //}

    //fn setInt32(reg: Reg, int32: Int32);

    //refine fn setInt32(reg: Reg, int32: Int32) {
        //MASM::setUnboxedValue(reg, Value::fromInt32(int32));
    //}

    //fn getObject(reg: Reg) -> Object;

    //refine fn getObject(reg: Reg) -> Object {
        //Value::toObject(MASM::getUnboxedValue(reg))
    //}

    //fn setObject(reg: Reg, object: Object);

    //refine fn setObject(reg: Reg, object: Object) {
        //MASM::setUnboxedValue(reg, Value::fromObject(object));
    //}
//}
