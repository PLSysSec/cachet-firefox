// vim: set tw=99 ts=4 sts=4 sw=4 et:

import "./MacroAssembler.cachet";

enum OperandLocationKind {
    Uninitialized,
    PayloadReg,
    FloatReg,
    ValueReg,
}

struct OperandLocation;

impl OperandLocation {
    fn kind(loc: OperandLocation) -> OperandLocationKind;

    fn newUninitialized() -> OperandLocation {
        let loc = (unsafe { OperandLocation::newUninitializedUnchecked() });
        assume OperandLocation::kind(loc) == OperandLocationKind::Uninitialized;
        loc
    }

    unsafe fn newUninitializedUnchecked() -> OperandLocation;

    fn setValueReg(out loc: OperandLocation, valueReg: ValueReg) {
        (unsafe { OperandLocation::setValueRegUnchecked(out loc, valueReg) });
        assume OperandLocation::kind(loc) == OperandLocationKind::ValueReg;
        assume (unsafe { OperandLocation::getValueRegUnchecked(loc) } ) == valueReg;
    }

    unsafe fn setValueRegUnchecked(out loc: OperandLocation, valueReg: ValueReg);

    fn getValueReg(loc: OperandLocation) -> ValueReg {
        assert OperandLocation::kind(loc) == OperandLocationKind::ValueReg;
        let valueReg = (unsafe { OperandLocation::getValueRegUnchecked(loc) });
        valueReg
    }

    unsafe fn getValueRegUnchecked(loc: OperandLocation) -> ValueReg;

    fn setPayloadReg(out loc: OperandLocation, reg: Reg, type: JSValueType) {
        (unsafe { OperandLocation::setPayloadRegUnchecked(out loc, reg, type) });
        assume OperandLocation::kind(loc) == OperandLocationKind::PayloadReg;
        assume (unsafe { OperandLocation::getPayloadRegUnchecked(loc) } ) == reg;
        assume (unsafe { OperandLocation::getPayloadTypeUnchecked(loc) } ) == type;
    }

    unsafe fn setPayloadRegUnchecked(out loc: OperandLocation, reg: Reg, type: JSValueType);

    fn getPayloadReg(loc: OperandLocation) -> Reg {
        assert OperandLocation::kind(loc) == OperandLocationKind::PayloadReg;
        let reg = (unsafe { OperandLocation::getPayloadRegUnchecked(loc) });
        reg
    }

    unsafe fn getPayloadRegUnchecked(loc: OperandLocation) -> Reg;

    fn getPayloadType(loc: OperandLocation) -> JSValueType {
        assert OperandLocation::kind(loc) == OperandLocationKind::PayloadReg;
        let type = (unsafe { OperandLocation::getPayloadTypeUnchecked(loc) });
        type
    }

    unsafe fn getPayloadTypeUnchecked(loc: OperandLocation) -> JSValueType;

    fn setFloatReg(out loc: OperandLocation, floatReg: FloatReg) {
        (unsafe { OperandLocation::setFloatRegUnchecked(out loc, floatReg) });
        assume OperandLocation::kind(loc) == OperandLocationKind::FloatReg;
        assume (unsafe { OperandLocation::getFloatRegUnchecked(loc) } ) == floatReg;
    }

    unsafe fn setFloatRegUnchecked(out loc: OperandLocation, floatReg: FloatReg);

    fn getFloatReg(loc: OperandLocation) -> FloatReg {
        assert OperandLocation::kind(loc) == OperandLocationKind::ValueReg;
        let floatReg = (unsafe { OperandLocation::getFloatRegUnchecked(loc) });
        floatReg
    }

    unsafe fn getFloatRegUnchecked(loc: OperandLocation) -> FloatReg;
}

struct OperandId;

impl OperandId {
    fn id(operandId: OperandId) -> UInt16;

    fn fromId(id: UInt16) -> OperandId {
        let operandId = unsafe { OperandId::fromIdUnchecked(id) };
        assume OperandId::id(operandId) == id;
        operandId
    }

    unsafe fn fromIdUnchecked(id: UInt16) -> OperandId;

    fn toValueId(operandId: OperandId) -> ValueId {
        ValueId::fromId(OperandId::id(operandId))
    }

    fn toObjectId(operandId: OperandId) -> ObjectId {
        ObjectId::fromId(OperandId::id(operandId))
    }

    fn toStringId(operandId: OperandId) -> StringId {
        StringId::fromId(OperandId::id(operandId))
    }

    fn toSymbolId(operandId: OperandId) -> SymbolId {
        SymbolId::fromId(OperandId::id(operandId))
    }

    fn toBoolId(operandId: OperandId) -> BoolId {
        BoolId::fromId(OperandId::id(operandId))
    }

    fn toInt32Id(operandId: OperandId) -> Int32Id {
        Int32Id::fromId(OperandId::id(operandId))
    }

    fn toNumberId(operandId: OperandId) -> NumberId {
        NumberId::fromId(OperandId::id(operandId))
    }

    fn toBigIntId(operandId: OperandId) -> BigIntId {
        BigIntId::fromId(OperandId::id(operandId))
    }

    fn toValueTagId(operandId: OperandId) -> ValueTagId {
        ValueTagId::fromId(OperandId::id(operandId))
    }

    fn toIntPtrId(operandId: OperandId) -> IntPtrId {
        IntPtrId::fromId(OperandId::id(operandId))
    }
}

struct ValueId <: OperandId;

impl ValueId {
    fn fromId(id: UInt16) -> ValueId {
        let valueId = unsafe { ValueId::fromIdUnchecked(id) };
        assume OperandId::id(valueId) == id;
        valueId
    }

    unsafe fn fromIdUnchecked(id: UInt16) -> ValueId;
}

struct ObjectId <: OperandId;

impl ObjectId {
    fn fromId(id: UInt16) -> ObjectId {
        let objectId = unsafe { ObjectId::fromIdUnchecked(id) };
        assume OperandId::id(objectId) == id;
        objectId
    }

    unsafe fn fromIdUnchecked(id: UInt16) -> ObjectId;
}

struct StringId <: OperandId;

impl StringId {
    fn fromId(id: UInt16) -> StringId {
        let stringId = unsafe { StringId::fromIdUnchecked(id) };
        assume OperandId::id(stringId) == id;
        stringId
    }

    unsafe fn fromIdUnchecked(id: UInt16) -> StringId;
}

struct SymbolId <: OperandId;

impl SymbolId {
    fn fromId(id: UInt16) -> SymbolId {
        let symbolId = unsafe { SymbolId::fromIdUnchecked(id) };
        assume OperandId::id(symbolId) == id;
        symbolId
    }

    unsafe fn fromIdUnchecked(id: UInt16) -> SymbolId;
}

struct BoolId <: OperandId;

impl BoolId {
    fn fromId(id: UInt16) -> BoolId {
        let boolId = unsafe { BoolId::fromIdUnchecked(id) };
        assume OperandId::id(boolId) == id;
        boolId
    }

    unsafe fn fromIdUnchecked(id: UInt16) -> BoolId;
}

struct Int32Id <: OperandId;

impl Int32Id {
    fn fromId(id: UInt16) -> Int32Id {
        let int32Id = unsafe { Int32Id::fromIdUnchecked(id) };
        assume OperandId::id(int32Id) == id;
        int32Id
    }

    unsafe fn fromIdUnchecked(id: UInt16) -> Int32Id;
}

struct NumberId <: ValueId;

impl NumberId {
    fn fromId(id: UInt16) -> NumberId {
        let numberId = unsafe { NumberId::fromIdUnchecked(id) };
        assume OperandId::id(numberId) == id;
        numberId
    }

    unsafe fn fromIdUnchecked(id: UInt16) -> NumberId;
}

struct BigIntId <: OperandId;

impl BigIntId {
    fn fromId(id: UInt16) -> BigIntId {
        let bigIntId = unsafe { BigIntId::fromIdUnchecked(id) };
        assume OperandId::id(bigIntId) == id;
        bigIntId
    }

    unsafe fn fromIdUnchecked(id: UInt16) -> BigIntId;
}

struct ValueTagId <: OperandId;

impl ValueTagId {
    fn fromId(id: UInt16) -> ValueTagId {
        let valueTagId = unsafe { ValueTagId::fromIdUnchecked(id) };
        assume OperandId::id(valueTagId) == id;
        valueTagId
    }

    unsafe fn fromIdUnchecked(id: UInt16) -> ValueTagId;
}

struct IntPtrId <: OperandId;

impl IntPtrId {
    fn fromId(id: UInt16) -> IntPtrId {
        let intPtrId = unsafe { IntPtrId::fromIdUnchecked(id) };
        assume OperandId::id(intPtrId) == id;
        intPtrId
    }

    unsafe fn fromIdUnchecked(id: UInt16) -> IntPtrId;
}

struct TypedId <: OperandId;

impl TypedId {
    fn type(typedId: TypedId) -> JSValueType;

    fn new(id: UInt16, type: JSValueType) -> TypedId {
        let typedId = unsafe { TypedId::newUnchecked(id, type) };
        assume OperandId::id(typedId) == id;
        assume TypedId::type(typedId) == type;
        typedId
    }

    unsafe fn newUnchecked(id: UInt16, type: JSValueType) -> TypedId;

    fn fromObjectId(objectId: ObjectId) -> TypedId {
        TypedId::new(OperandId::id(objectId), JSValueType::Object)
    }

    fn toObjectId(typedId: TypedId) -> ObjectId {
        assert TypedId::type(typedId) == JSValueType::Object;
        OperandId::toObjectId(typedId)
    }

    fn fromStringId(stringId: StringId) -> TypedId {
        TypedId::new(OperandId::id(stringId), JSValueType::String)
    }

    fn toStringId(typedId: TypedId) -> StringId {
        assert TypedId::type(typedId) == JSValueType::String;
        OperandId::toStringId(typedId)
    }

    fn fromSymbolId(symbolId: SymbolId) -> TypedId {
        TypedId::new(OperandId::id(symbolId), JSValueType::Symbol)
    }

    fn toSymbolId(typedId: TypedId) -> SymbolId {
        assert TypedId::type(typedId) == JSValueType::Symbol;
        OperandId::toSymbolId(typedId)
    }

    fn fromBoolId(boolId: BoolId) -> TypedId {
        TypedId::new(OperandId::id(boolId), JSValueType::Bool)
    }

    fn toBoolId(typedId: TypedId) -> BoolId {
        assert TypedId::type(typedId) == JSValueType::Bool;
        OperandId::toBoolId(typedId)
    }

    fn fromInt32Id(int32Id: Int32Id) -> TypedId {
        TypedId::new(OperandId::id(int32Id), JSValueType::Int32)
    }

    fn toInt32Id(typedId: TypedId) -> Int32Id {
        assert TypedId::type(typedId) == JSValueType::Int32;
        OperandId::toInt32Id(typedId)
    }

    fn fromBigIntId(bigIntId: BigIntId) -> TypedId {
        TypedId::new(OperandId::id(bigIntId), JSValueType::BigInt)
    }

    fn toBigIntId(typedId: TypedId) -> BigIntId {
        assert TypedId::type(typedId) == JSValueType::BigInt;
        OperandId::toBigIntId(typedId)
    }

    fn fromValueTagId(valueTagId: ValueTagId) -> TypedId {
        TypedId::new(OperandId::id(valueTagId), JSValueType::Unknown)
    }

    fn toValueTagId(typedId: TypedId) -> ValueTagId {
        assert TypedId::type(typedId) == JSValueType::Unknown;
        OperandId::toValueTagId(typedId)
    }
}

struct Int32Field;

impl Int32Field {
    fn fromOffset(offset: UInt32) -> Int32Field;
}

struct IntPtrField;

impl IntPtrField {
    fn fromOffset(offset: UInt32) -> IntPtrField;
}

struct ShapeField;

impl ShapeField {
    fn fromOffset(offset: UInt32) -> ShapeField;
}

// FIXME(spinda): Not a real field type.
struct ClassField;

impl ClassField {
    fn fromOffset(offset: UInt32) -> ClassField;
}

struct GetterSetterField;

impl GetterSetterField {
    fn fromOffset(offset: UInt32) -> GetterSetterField;
}

struct ObjectField;

impl ObjectField {
    fn fromOffset(offset: UInt32) -> ObjectField;
}

struct SymbolField;

impl SymbolField {
    fn fromOffset(offset: UInt32) -> SymbolField;
}

struct StringField;

impl StringField {
    fn fromOffset(offset: UInt32) -> StringField;
}

struct BaseScriptField;

impl BaseScriptField {
    fn fromOffset(offset: UInt32) -> BaseScriptField;
}

struct IdField;

impl IdField {
    fn fromOffset(offset: UInt32) -> IdField;
}

struct AllocSiteField;

impl AllocSiteField {
    fn fromOffset(offset: UInt32) -> AllocSiteField;
}

struct Int64Field;

impl Int64Field {
    fn fromOffset(offset: UInt32) -> Int64Field;
}

struct ValueField;

impl ValueField {
    fn fromOffset(offset: UInt32) -> ValueField;
}

enum GuardClassKind {
    Array,
    PlainObject,
    ArrayBuffer,
    SharedArrayBuffer,
    DataView,
    MappedArguments,
    UnmappedArguments,
    WindowProxy,
    JSFunction,
    Set,
    Map,
}

struct FailurePath {
    label label_: MASM
}

impl FailurePath {
    fn setHasAutoScratchFloatRegister(failure: FailurePath);
    fn clearHasAutoScratchFloatRegister(failure: FailurePath);
}

ir CacheIR emits MASM {
    op ReturnFromIC() {}

    op Assert(cond: Bool) {
        emit MASM::Assert(cond);
    }

    op AssertEqValueOutput(value: Value) {
        let scratchValueReg = CacheIR::allocateValueReg();

        emit MASM::AssertEqValue(
            TypedOrValueReg::toValueReg(CacheIR::outputReg), value, scratchValueReg);

        CacheIR::releaseValueReg(scratchValueReg);
    }

    op GuardIsNumber(inputId: ValueId) {
        let knownType = CacheIR::knownType(inputId);

        if knownType == JSValueType::Double || knownType == JSValueType::Int32 {
           return;
        }

        let inputReg = CacheIR::useValueId(inputId);

        let failure = CacheIR::addFailurePath();
        emit MASM::BranchTestNumber(Condition::NotEqual, inputReg, failure.label_);
        CacheIR::releaseFailurePath();
    }

    op GuardIsNullOrUndefined(inputId: ValueId) {
        let knownType = CacheIR::knownType(inputId);
        if knownType == JSValueType::Undefined || knownType == JSValueType::Null {
            return;
        }

        let inputReg = CacheIR::useValueId(inputId);

        let failure = CacheIR::addFailurePath();

        label success: MASM;

        emit MASM::BranchTestNull(Condition::Equal, inputReg, success);
        emit MASM::BranchTestUndefined(Condition::NotEqual, inputReg, failure.label_);

        bind success;

        CacheIR::releaseFailurePath();
    }

    op GuardIsNull(inputId: ValueId) {
        if CacheIR::knownType(inputId) == JSValueType::Null {
            return;
        }

        let inputReg = CacheIR::useValueId(inputId);

        let failure = CacheIR::addFailurePath();

        emit MASM::BranchTestNull(Condition::NotEqual, inputReg, failure.label_);

        CacheIR::releaseFailurePath();
    }

    op GuardIsUndefined(inputId: ValueId) {
        if CacheIR::knownType(inputId) == JSValueType::Undefined {
            return;
        }

        let inputReg = CacheIR::useValueId(inputId);

        let failure = CacheIR::addFailurePath();

        emit MASM::BranchTestUndefined(Condition::NotEqual, inputReg, failure.label_);

        CacheIR::releaseFailurePath();
    }

    op GuardIsNativeObject(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectId(objectId);
        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::BranchIfNonNativeObj(objectReg, scratchReg, failure.label_);

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op GuardIsProxy(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectId(objectId);
        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::BranchTestObjectIsProxy(false, objectReg, scratchReg, failure.label_);

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op GuardInt32IsNonNegative(indexId: Int32Id) {
        let indexReg = CacheIR::useInt32Id(indexId);

        let failure = CacheIR::addFailurePath();

        emit MASM::Branch32Imm(Condition::LessThan, indexReg, 0_i32, failure.label_);

        CacheIR::releaseFailurePath();
    }

    op GuardToInt32Index(inputId: ValueId, resultId: Int32Id) {
        let outputReg = CacheIR::defineInt32Id(resultId);

        if CacheIR::knownType(inputId) == JSValueType::Int32 {
            let int32Id = Int32Id::fromId(OperandId::id(inputId));
            let inputReg = CacheIR::useInt32Id(int32Id);
            emit MASM::Move32Int32(inputReg, outputReg);
            return;
        }

        let inputReg = CacheIR::useValueId(inputId);

        let failure = CacheIR::addFailurePath();

        label done: MASM;
        {
            let tagReg = CacheIR::allocateScratchReg();
            emit MASM::SplitTagForTest(inputReg, tagReg);

            label notInt32: MASM;
            emit MASM::BranchTestInt32Tag(Condition::NotEqual, tagReg, notInt32);
            {
                CacheIR::releaseScratchReg();

                emit MASM::UnboxInt32(inputReg, outputReg);
                emit MASM::Jump(done);

                CacheIR::allocateScratchReg();
            }
            bind notInt32;

            emit MASM::BranchTestDoubleTag(Condition::NotEqual, tagReg, failure.label_);
            {
                CacheIR::releaseScratchReg();

                let floatReg = CacheIR::allocateFloatScratchRegWithFailurePath(failure);
                label failurePopReg: MASM;
                emit MASM::UnboxDouble(inputReg, floatReg);
                emit MASM::ConvertDoubleToInt32(floatReg, outputReg, failurePopReg, false);
                CacheIR::releaseFloatScratchRegWithFailurePath(failure, out failurePopReg);

                CacheIR::allocateScratchReg();
            }

            CacheIR::releaseScratchReg();
        }
        bind done;

        CacheIR::releaseFailurePath();
    }

    op IsObjectResult(inputId: ValueId) {
        let scratchReg = CacheIR::allocateReg();
        let valueReg = CacheIR::useValueId(inputId);

        emit MASM::TestObjectSet(Condition::Equal, valueReg, scratchReg);
        emit MASM::TagValue(JSValueType::Bool, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
    }

    op GuardNonDoubleType(inputId: ValueId, type: ValueType) {
        if CacheIR::knownType(inputId) == JSValueType::fromValueType(type) {
            return;
        }

        let inputReg = CacheIR::useValueId(inputId);

        let failure = CacheIR::addFailurePath();

        if type == ValueType::String {
            emit MASM::BranchTestString(Condition::NotEqual, inputReg, failure.label_);
        } else if type == ValueType::Symbol {
            emit MASM::BranchTestSymbol(Condition::NotEqual, inputReg, failure.label_);
        } else if type == ValueType::BigInt {
            emit MASM::BranchTestBigInt(Condition::NotEqual, inputReg, failure.label_);
        } else if type == ValueType::Int32 {
            emit MASM::BranchTestInt32(Condition::NotEqual, inputReg, failure.label_);
        } else if type == ValueType::Bool {
            emit MASM::BranchTestBoolean(Condition::NotEqual, inputReg, failure.label_);
        } else if type == ValueType::Undefined {
            emit MASM::BranchTestUndefined(Condition::NotEqual, inputReg, failure.label_);
        } else if type == ValueType::Null {
            emit MASM::BranchTestNull(Condition::NotEqual, inputReg, failure.label_);
        } else {
            assert false;
        }

        CacheIR::releaseFailurePath();
    }

    op GuardClass(objId: ObjectId, kind: GuardClassKind) {
        let objReg = CacheIR::useObjectId(objId);
        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        let class = ArrayObject::class();

        if kind == GuardClassKind::Array {
            class = ArrayObject::class();
        } else if kind == GuardClassKind::ArrayBuffer {
            class = ArrayBufferObject::class();
        } else if kind == GuardClassKind::SharedArrayBuffer {
            class = SharedArrayBufferObject::class();
        } else if kind == GuardClassKind::DataView {
            class = DataViewObject::class();
        } else if kind == GuardClassKind::MappedArguments {
            class = MappedArgumentsObject::class();
        } else if kind == GuardClassKind::UnmappedArguments {
            class = UnmappedArgumentsObject::class();
        } else if kind == GuardClassKind::WindowProxy {
            class = Class::windowProxyClass();
        } else if kind == GuardClassKind::Set {
            class = SetObject::class();
        } else if kind == GuardClassKind::Map {
            class = MapObject::class();
        } else if kind == GuardClassKind::JSFunction {
            class = JSFunction::class();
        } else {
            assert false;
        }

        if CacheIR::objectGuardNeedsSpectreMitigations(objId) {
            emit MASM::BranchTestObjClass(Condition::NotEqual, objReg, class, scratchReg, objReg,
                    failure.label_);
        } else {
            emit MASM::BranchTestObjClassNoSpectreMitigations(Condition::NotEqual, objReg, class,
                    scratchReg, failure.label_);
        }

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op GuardBooleanToInt32(inputId: ValueId, resultId: Int32Id) {
        let resultReg = CacheIR::defineInt32Id(resultId);

        if CacheIR::knownType(inputId) == JSValueType::Bool {
            let boolId = BoolId::fromId(OperandId::id(inputId));
            let inputReg = CacheIR::useBoolId(boolId);
            emit MASM::Move32Bool(inputReg, resultReg);
            emit MASM::CastBoolToInt32(resultReg);
            return;
        }

        let inputReg = CacheIR::useValueId(inputId);

        let failure = CacheIR::addFailurePath();

        emit MASM::FallibleUnboxBoolean(inputReg, resultReg, failure.label_);
        emit MASM::CastBoolToInt32(resultReg);

        CacheIR::releaseFailurePath();
    }

    op GuardToObject(inputId: ValueId) {
        if CacheIR::knownType(inputId) == JSValueType::Object {
            return;
        }

        let inputReg = CacheIR::useValueId(inputId);

        let failure = CacheIR::addFailurePath();

        emit MASM::BranchTestObject(Condition::NotEqual, inputReg, failure.label_);

        CacheIR::releaseFailurePath();
    }

    op GuardShape(objectId: ObjectId, shapeField: ShapeField) {
        let objectReg = CacheIR::useObjectId(objectId);
        let shape = CacheIR::readShapeField(shapeField);

        let maybeScratchReg = MaybeReg::none();
        let needsSpectreMitigations = CacheIR::objectGuardNeedsSpectreMitigations(objectId);
        if needsSpectreMitigations {
            maybeScratchReg = MaybeReg::fromReg(CacheIR::allocateReg());
        }

        let failure = CacheIR::addFailurePath();

        if needsSpectreMitigations {
            let scratchReg = MaybeReg::toReg(maybeScratchReg);
            emit MASM::BranchTestObjectShape(
                    Condition::NotEqual, objectReg, shape, scratchReg, objectReg, failure.label_
                    );
            CacheIR::releaseReg(scratchReg);
        } else {
            emit MASM::BranchTestObjectShapeNoSpectreMitigations(
                    Condition::NotEqual, objectReg, shape, failure.label_
                    );
        }

        CacheIR::releaseFailurePath();
    }

    op GuardAnyClass(objectId: ObjectId, classField: ClassField) {
        let objectReg = CacheIR::useObjectId(objectId);
        let scratchReg = CacheIR::allocateReg();
        let class = CacheIR::readClassField(classField);

        let maybeScratchReg = MaybeReg::none();
        let needsSpectreMitigations = CacheIR::objectGuardNeedsSpectreMitigations(objectId);
        if needsSpectreMitigations {
            maybeScratchReg = MaybeReg::fromReg(CacheIR::allocateReg());
        }

        let failure = CacheIR::addFailurePath();

        if needsSpectreMitigations {
            let scratchReg = MaybeReg::toReg(maybeScratchReg);
            emit MASM::BranchTestObjClass(
                Condition::NotEqual, objectReg, class, scratchReg, objectReg, failure.label_
            );
            CacheIR::releaseReg(scratchReg);
        } else {
            emit MASM::BranchTestObjClassNoSpectreMitigations(
                Condition::NotEqual, objectReg, class, scratchReg, failure.label_
            );
        }

        CacheIR::releaseFailurePath();
    }

    op GuardFixedSlotValue(objId: ObjectId,
                           offsetOffset: Int32Field,
                           valOffset: ValueField) {
        let obj = CacheIR::useObjectId(objId);
        let offset = CacheIR::allocateReg();
        let scratchVal = CacheIR::allocateValueReg();

        let failure = CacheIR::addFailurePath();

        CacheIR::emitLoadInt32StubField(offsetOffset, offset);
        CacheIR::emitLoadValueStubField(valOffset, scratchVal);

        let slotVal = BaseIndex::new(obj, offset, Scale::TimesOne, 0_u32);
        emit MASM::BranchTestValue(
            Condition::NotEqual, slotVal, scratchVal, failure.label_
        );

        CacheIR::releaseReg(offset);
        CacheIR::releaseValueReg(scratchVal);
        CacheIR::releaseFailurePath();
    }

    op GuardDynamicSlotValue(objId: ObjectId,
                           offsetOffset: Int32Field,
                           valOffset: ValueField) {
        let obj = CacheIR::useObjectId(objId);
        let objSlots = CacheIR::allocateReg();
        let offset = CacheIR::allocateReg();
        let scratchVal = CacheIR::allocateValueReg();

        let failure = CacheIR::addFailurePath();

        let objOffsetAddr = Address::new(obj, NativeObject::offsetOfSlots as Int32);
        emit MASM::LoadPtrAddress(objOffsetAddr, objSlots);

        CacheIR::emitLoadInt32StubField(offsetOffset, offset);
        CacheIR::emitLoadValueStubField(valOffset, scratchVal);

        let slotVal = BaseIndex::new(objSlots, offset, Scale::TimesOne, 0_u32);
        emit MASM::BranchTestValue(
            Condition::NotEqual, slotVal, scratchVal, failure.label_
        );

        CacheIR::releaseReg(objSlots);
        CacheIR::releaseReg(offset);
        CacheIR::releaseValueReg(scratchVal);
        CacheIR::releaseFailurePath();
    }

    op GuardToString(inputId: ValueId) {
        if CacheIR::knownType(inputId) == JSValueType::String {
            return;
        }

        let inputReg = CacheIR::useValueId(inputId);

        let failure = CacheIR::addFailurePath();

        emit MASM::BranchTestString(Condition::NotEqual, inputReg, failure.label_);

        CacheIR::releaseFailurePath();
    }

    op GuardToSymbol(inputId: ValueId) {
        if CacheIR::knownType(inputId) == JSValueType::Symbol {
            return;
        }

        let inputReg = CacheIR::useValueId(inputId);

        let failure = CacheIR::addFailurePath();

        emit MASM::BranchTestSymbol(Condition::NotEqual, inputReg, failure.label_);

        CacheIR::releaseFailurePath();
    }

    op GuardToInt32(inputId: ValueId) {
        if CacheIR::knownType(inputId) == JSValueType::Int32 {
            return;
        }
        let inputReg = CacheIR::useValueId(inputId);

        let failure = CacheIR::addFailurePath();

        emit MASM::BranchTestInt32(Condition::NotEqual, inputReg, failure.label_);

        CacheIR::releaseFailurePath();
    }

    op GuardToBoolean(inputId: ValueId) {
        if CacheIR::knownType(inputId) == JSValueType::Bool {
            return;
        }

        let inputReg = CacheIR::useValueId(inputId);

        let failure = CacheIR::addFailurePath();

        emit MASM::BranchTestBoolean(Condition::NotEqual, inputReg, failure.label_);

        CacheIR::releaseFailurePath();
    }

    op GuardToBigInt(inputId: ValueId) {
        if CacheIR::knownType(inputId) == JSValueType::BigInt {
            return;
        }

        let inputReg = CacheIR::useValueId(inputId);

        let failure = CacheIR::addFailurePath();

        emit MASM::BranchTestBigInt(Condition::NotEqual, inputReg, failure.label_);

        CacheIR::releaseFailurePath();
    }

    op GuardNoDenseElements(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectId(objectId);
        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::LoadPtrAddress(
            Address::new(objectReg, NativeObject::offsetOfElements as Int32), scratchReg
        );

        let initLength = Address::new(scratchReg, NativeObjectElements::offsetOfInitializedLength as Int32);

        emit MASM::Branch32AddressImm32(Condition::NotEqual, initLength, 0_i32, failure.label_);

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op GuardTagNotEqual(lhsId: ValueTagId, rhsId: ValueTagId) {
        let lhsReg = CacheIR::useValueTagId(lhsId);
        let rhsReg = CacheIR::useValueTagId(rhsId);

        let failure = CacheIR::addFailurePath();

        label done: MASM;

        emit MASM::Branch32Tag(Condition::Equal, lhsReg, rhsReg, failure.label_);

        emit MASM::BranchTestNumberTag(Condition::NotEqual, lhsReg, done);
        emit MASM::BranchTestNumberTag(Condition::NotEqual, rhsReg, done);

        emit MASM::Jump(failure.label_);

        bind done;

        CacheIR::releaseFailurePath();
    }

    op GuardSpecificAtom(strId: StringId, stringField: StringField) {
        let strReg = CacheIR::useStringId(strId);
        let scratchReg = CacheIR::allocateReg();

        let atom = String::asAtom(CacheIR::readStringField(stringField));

        let failure = CacheIR::addFailurePath();

        let volatileRegs = LiveRegSet::new(
            GeneralRegSet::volatile(), CacheIR::liveVolatileFloatRegs()
        );
        LiveRegSet::takeReg(out volatileRegs, volatileRegs, scratchReg);

        emit MASM::GuardSpecificAtom(strReg, atom, scratchReg, volatileRegs, failure.label_);

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op BooleanToNumber(boolId: BoolId, resultId: NumberId) {
        let boolReg = CacheIR::useBoolId(boolId);
        let resultReg = CacheIR::defineNumberId(resultId);

        emit MASM::CastBoolToInt32(boolReg);
        emit MASM::TagValue(JSValueType::Int32, boolReg, resultReg);
    }

    op LoadObject(resultId: ObjectId, objField: ObjectField) {
        let resultReg = CacheIR::defineObjectId(resultId);
        CacheIR::emitLoadObjectStubField(objField, resultReg);
    }

    op LoadObjectResult(objId: ObjectId) {
        let objectReg = CacheIR::useObjectId(objId);
        CacheIR::emitStoreResult(objectReg, JSValueType::Object, CacheIR::outputReg);
    }

    op LoadProto(objectId: ObjectId, resultId: ObjectId) {
        let objectReg = CacheIR::useObjectId(objectId);
        let resultReg = CacheIR::defineObjectId(resultId);

        emit MASM::LoadObjectProto(objectReg, resultReg);

        // #ifdef DEBUG
        label done: MASM;
        emit MASM::BranchTestObjectProto(resultReg, done);
        emit MASM::AssumeUnreachable();
        bind done;
        // #endif

        emit MASM::UnboxObjectProto(resultReg);
    }

    op LoadValueTag(valId: ValueId, resultId: ValueTagId) {
        let valReg = CacheIR::useValueId(valId);
        let resultReg = CacheIR::defineValueTagId(resultId);

        let tagReg = MASM::extractTag(valReg, resultReg);
        if(tagReg != resultReg) {
            emit MASM::Move(tagReg, resultReg);
        }
    }

    op LoadFixedSlotResult(objectId: ObjectId, slotField: Int32Field) {
        let objectReg = CacheIR::useObjectId(objectId);
        let slotOffset = CacheIR::readInt32Field(slotField);

        emit MASM::LoadTypedOrValueAddress(Address::new(objectReg, slotOffset), CacheIR::outputReg);
    }

    op LoadDynamicSlotResult(objectId: ObjectId, slotField: Int32Field) {
        let objectReg = CacheIR::useObjectId(objectId);
        let slotOffset = CacheIR::readInt32Field(slotField);

        let scratchReg = CacheIR::allocateReg();
        emit MASM::LoadPtrAddress(
            Address::new(objectReg, NativeObject::offsetOfSlots as Int32), scratchReg
        );
        emit MASM::LoadTypedOrValueAddress(
            Address::new(scratchReg, slotOffset), CacheIR::outputReg
        );

        CacheIR::releaseReg(scratchReg);
    }

    op LoadDenseElementResult(objectId: ObjectId, indexId: Int32Id) {
        let objReg = CacheIR::useObjectId(objectId);
        let indexReg = CacheIR::useInt32Id(indexId);

        let scratchReg1 = CacheIR::allocateReg();
        let scratchReg2 = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::LoadPtrAddress(
            Address::new(objReg, NativeObject::offsetOfElements as Int32), scratchReg1
        );

        let initLength = Address::new(scratchReg1,
                NativeObjectElements::offsetOfInitializedLength);
        emit MASM::SpectreBoundsCheck32Address(indexReg, initLength, scratchReg2, failure.label_);

        let element = BaseObjectElementIndex::new(scratchReg1, indexReg, 0_u32);
        emit MASM::BranchTestMagicBaseObjectElementIndex(Condition::Equal, element, failure.label_);
        emit MASM::LoadTypedOrValueBaseObjectElementIndex(element, CacheIR::outputReg);

        CacheIR::releaseReg(scratchReg2);
        CacheIR::releaseReg(scratchReg1);
        CacheIR::releaseFailurePath();
    }

    op LoadDenseElementHoleResult(objId: ObjectId, indexId: Int32Id) {
        let objReg = CacheIR::useObjectId(objId);
        let indexReg = CacheIR::useInt32Id(indexId);

        let scratchReg1 = CacheIR::allocateReg();
        let scratchReg2 = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::Branch32Imm(Condition::LessThan, indexReg, 0_i32, failure.label_);

        emit MASM::LoadPtrAddress(
            Address::new(objReg, NativeObject::offsetOfElements as Int32), scratchReg1
        );

        label hole: MASM;

        let initLength = Address::new(scratchReg1,
                NativeObjectElements::offsetOfInitializedLength);
        emit MASM::SpectreBoundsCheck32Address(indexReg, initLength, scratchReg2, hole);

        label done: MASM;

        let element = BaseObjectElementIndex::new(scratchReg1, indexReg, 0_u32);
        emit MASM::LoadValueBaseObjectElementIndex(element,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));
        emit MASM::BranchTestMagic(Condition::NotEqual,
                TypedOrValueReg::toValueReg(CacheIR::outputReg), done);

        bind hole;
        emit MASM::MoveValueImm(Value::getUndefined(),
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        bind done;

        CacheIR::releaseReg(scratchReg2);
        CacheIR::releaseReg(scratchReg1);
        CacheIR::releaseFailurePath();
    }

    op LoadInt32ArrayLengthResult(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectId(objectId);
        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::LoadPtrAddress(
            Address::new(objectReg, NativeObject::offsetOfElements as Int32), scratchReg
        );
        emit MASM::Load32Address(
            Address::new(scratchReg, NativeObjectElements::offsetOfLength), scratchReg
        );

        emit MASM::BranchTest32(Condition::Signed, scratchReg, scratchReg, failure.label_);
        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op LoadArgumentsObjectLengthResult(objectId: ObjectId) {
        let objectReg = CacheIR::useObjectId(objectId);
        let argObjLengthReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::LoadArgumentsObjectLength(objectReg, argObjLengthReg, failure.label_);
        emit MASM::TagValue(JSValueType::Int32, argObjLengthReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(argObjLengthReg);
        CacheIR::releaseFailurePath();
    }

    op LoadArgumentsObjectArgResult(objId: ObjectId, indexId: Int32Id) {
        let objReg = CacheIR::useObjectId(objId);
        let indexReg = CacheIR::useInt32Id(indexId);

        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::LoadArgumentsObjectElement(objReg, indexReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg), scratchReg, failure.label_);

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op LoadInstanceOfObjectResult(lhsId: ValueId, protoId: ObjectId) {
        let lhsReg = CacheIR::useValueId(lhsId);
        let protoReg = CacheIR::useObjectId(protoId);
        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        label returnFalse: MASM;
        label returnTrue: MASM;
        label done: MASM;

        emit MASM::FallibleUnboxObject(lhsReg, scratchReg, returnFalse);
        emit MASM::LoadObjectProto(scratchReg, scratchReg);

        label loopHead: MASM;
        bind loopHead;

        emit MASM::BranchObjectProto(Condition::Equal, scratchReg, protoReg, returnTrue);
        emit MASM::BranchTestNullProto(scratchReg, returnFalse);
        emit MASM::BranchTestLazyProto(scratchReg, failure.label_);

        emit MASM::UnboxObjectProto(scratchReg);
        emit MASM::LoadObjectProto(scratchReg, scratchReg);
        //emit MASM::StoreBool(true, protoReg); <-- uncomment to induce error
        emit MASM::Jump(loopHead);

        bind returnFalse;
        CacheIR::emitStoreBool(false, CacheIR::outputReg);
        emit MASM::Jump(done);

        bind returnTrue;
        CacheIR::emitStoreBool(true, CacheIR::outputReg);

        bind done;

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op LoadStringResult(stringId: StringId) {
        let stringReg = CacheIR::useStringId(stringId);
        emit MASM::TagValue(JSValueType::String, stringReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));
    }

    op LoadSymbolResult(symbolId: SymbolId) {
        let symbolReg = CacheIR::useSymbolId(symbolId);
        emit MASM::TagValue(JSValueType::Symbol, symbolReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));
    }

    op LoadInt32Result(int32Id: Int32Id) {
        let int32Reg = CacheIR::useInt32Id(int32Id);
        emit MASM::TagValue(JSValueType::Int32, int32Reg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));
    }

    op LoadBooleanResult(bool: Bool) {
        CacheIR::emitStoreBool(bool, CacheIR::outputReg);
    }

    op LoadUndefinedResult() {
        let value = Value::getUndefined();
        emit MASM::MoveValueImm(value, TypedOrValueReg::toValueReg(CacheIR::outputReg));
    }

    op LoadBigIntResult(bigIntId: BigIntId) {
        let bigIntReg = CacheIR::useBigIntId(bigIntId);
        emit MASM::TagValue(JSValueType::BigInt, bigIntReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));
    }

    op LoadDoubleResult(numberId: NumberId) {
        let numberReg = CacheIR::useNumberId(numberId);

        // #ifdef DEBUG
        label ok: MASM;
        emit MASM::BranchTestDouble(Condition::Equal, numberReg, ok);
        emit MASM::BranchTestInt32(Condition::Equal, numberReg, ok);
        emit MASM::AssumeUnreachable();
        bind ok;
        // #endif

        emit MASM::MoveValue(numberReg, TypedOrValueReg::toValueReg(CacheIR::outputReg));
        emit MASM::ConvertInt32ValueToDouble(TypedOrValueReg::toValueReg(CacheIR::outputReg));
    }

    op LoadInt32Constant(valField: Int32Field, resultId: Int32Id) {
        let resultReg = CacheIR::defineInt32Id(resultId);

        CacheIR::emitLoadInt32StubField(valField, resultReg);
    }

    op LoadInt32TruthyResult(inputId: ValueId) {
        let valueReg = CacheIR::useValueId(inputId);

        label ifFalse: MASM;
        label done: MASM;
        emit MASM::BranchTestInt32Truthy(false, valueReg, ifFalse);
        emit MASM::MoveValueImm(Value::fromBool(true),
                TypedOrValueReg::toValueReg(CacheIR::outputReg));
        emit MASM::Jump(done);

        bind ifFalse;
        emit MASM::MoveValueImm(Value::fromBool(false),
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        bind done;
    }

    op CompareNullUndefinedResult(jsop: JSOp, isUndefined: Bool, inputId: ValueId) {
        let inputReg = CacheIR::useValueId(inputId);
        let scratchReg = CacheIR::allocateReg();

        if JSOp::isStrictEqualityOp(jsop) {
            if isUndefined {
                emit MASM::TestUndefinedSet(Condition::fromJSOp(jsop, false), inputReg, scratchReg);
            } else {
                emit MASM::TestNullSet(Condition::fromJSOp(jsop, false), inputReg, scratchReg);
            }

            CacheIR::emitStoreResult(scratchReg, JSValueType::Bool, CacheIR::outputReg);
            return;
        }

        let failure = CacheIR::addFailurePath();

        assert JSOp::isLooseEqualityOp(jsop);

        label nullOrLikeUndefined: MASM;
        label notNullOrLikeUndefined: MASM;
        label done: MASM;

        {
            let tagReg = CacheIR::allocateScratchReg();
            emit MASM::SplitTagForTest(inputReg, tagReg);

            if isUndefined {
                emit MASM::BranchTestUndefinedTag(Condition::Equal, tagReg, nullOrLikeUndefined);
                emit MASM::BranchTestNullTag(Condition::Equal, tagReg, nullOrLikeUndefined);
            } else {
                emit MASM::BranchTestNullTag(Condition::Equal, tagReg, nullOrLikeUndefined);
                emit MASM::BranchTestUndefinedTag(Condition::Equal, tagReg, nullOrLikeUndefined);
            }
            emit MASM::BranchTestObjectTag(Condition::NotEqual, tagReg, notNullOrLikeUndefined);

            {
                CacheIR::releaseScratchReg();

                emit MASM::UnboxObject(inputReg, scratchReg);
                emit MASM::BranchIfObjectEmulatesUndefined(scratchReg, scratchReg, failure.label_, nullOrLikeUndefined);
                emit MASM::Jump(notNullOrLikeUndefined);

                CacheIR::allocateScratchReg();
            }

            CacheIR::releaseScratchReg();
        }

        bind nullOrLikeUndefined;
        CacheIR::emitStoreBool(jsop == JSOp::Eq, CacheIR::outputReg);
        emit MASM::Jump(done);

        bind notNullOrLikeUndefined;
        CacheIR::emitStoreBool(jsop == JSOp::Ne, CacheIR::outputReg);

        bind done;

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op CompareInt32Result(jsop: JSOp, lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Id(lhsId);
        let rhsReg = CacheIR::useInt32Id(rhsId);

        label ifTrue: MASM;
        label done: MASM;

        emit MASM::Branch32(Condition::fromJSOp(jsop, true), lhsReg, rhsReg, ifTrue);
        CacheIR::emitStoreBool(false, CacheIR::outputReg);
        emit MASM::Jump(done);

        bind ifTrue;
        CacheIR::emitStoreBool(true, CacheIR::outputReg);
        bind done;

    }

    op Int32AddResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Id(lhsId);
        let rhsReg = CacheIR::useInt32Id(rhsId);
        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::Move(rhsReg, scratchReg);
        emit MASM::BranchAdd32(Condition::Overflow, lhsReg, scratchReg, failure.label_);
        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op Int32SubResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Id(lhsId);
        let rhsReg = CacheIR::useInt32Id(rhsId);
        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::Move(lhsReg, scratchReg);
        emit MASM::BranchSub32(Condition::Overflow, rhsReg, scratchReg, failure.label_);
        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op Int32MulResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Id(lhsId);
        let rhsReg = CacheIR::useInt32Id(rhsId);

        let scratchReg = CacheIR::allocateReg();
        let scratch2Reg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        label maybeNegZero: MASM;
        label done: MASM;

        emit MASM::Move(lhsReg, scratchReg);
        emit MASM::BranchMul32(Condition::Overflow, rhsReg, scratchReg, failure.label_);
        emit MASM::BranchTest32(Condition::Zero, scratchReg, scratchReg, maybeNegZero);
        emit MASM::Jump(done);

        bind maybeNegZero;
        emit MASM::Move(lhsReg, scratch2Reg);
        emit MASM::Or32(rhsReg, scratch2Reg);
        emit MASM::BranchTest32(Condition::Signed, scratch2Reg, scratch2Reg, failure.label_);

        bind done;
        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseReg(scratch2Reg);
        CacheIR::releaseFailurePath();
    }

    op Int32DivResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Id(lhsId);
        let rhsReg = CacheIR::useInt32Id(rhsId);

        let remReg = CacheIR::allocateReg();
        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        // prevent division by 0.
        emit MASM::BranchTest32(Condition::Zero, rhsReg, rhsReg, failure.label_);

        // prevent -2147483648 / -1.
        label notOverflow: MASM;
        emit MASM::Branch32Imm(Condition::NotEqual, lhsReg, -2147483647_i32 - 1_i32, notOverflow);
        emit MASM::Branch32Imm(Condition::Equal, rhsReg, -1_i32, failure.label_);
        bind notOverflow;

        // prevent negative 0.
        label notZero: MASM;
        emit MASM::BranchTest32(Condition::NonZero, lhsReg, lhsReg, notZero);
        emit MASM::BranchTest32(Condition::Signed, rhsReg, rhsReg, failure.label_);
        bind notZero;

        emit MASM::Move(lhsReg, scratchReg);
        let volatileRegs = LiveRegSet::new(
            GeneralRegSet::volatile(), CacheIR::liveVolatileFloatRegs()
        );
        emit MASM::FlexibleDivMod32(rhsReg, scratchReg, remReg, false, volatileRegs);

        // A remainder implies a double result.
        emit MASM::BranchTest32(Condition::NonZero, remReg, remReg, failure.label_);

        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(remReg);
        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op Int32ModResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Id(lhsId);
        let rhsReg = CacheIR::useInt32Id(rhsId);

        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        // x % 0 results in NaN.
        emit MASM::BranchTest32(Condition::Zero, rhsReg, rhsReg, failure.label_);

        // Prevent -2147483648 % -1.
        label notOverflow: MASM;
        emit MASM::Branch32Imm(Condition::NotEqual, lhsReg, -2147483647_i32 - 1_i32, notOverflow);
        emit MASM::Branch32Imm(Condition::Equal, rhsReg, -1_i32, failure.label_);
        bind notOverflow;

        emit MASM::Move(lhsReg, scratchReg);
        let volatileRegs = LiveRegSet::new(
            GeneralRegSet::volatile(), CacheIR::liveVolatileFloatRegs()
        );
        emit MASM::FlexibleRemainder32(rhsReg, scratchReg, false, volatileRegs);

        // Modulo takes the sign of the dividend; we can't return negative zero here.
        label notZero: MASM;
        emit MASM::BranchTest32(Condition::NonZero, scratchReg, scratchReg, notZero);
        emit MASM::BranchTest32(Condition::Signed, lhsReg, lhsReg, failure.label_);
        bind notZero;

        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op Int32BitOrResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Id(lhsId);
        let rhsReg = CacheIR::useInt32Id(rhsId);

        let scratchReg = CacheIR::allocateReg();
        emit MASM::Move(rhsReg, scratchReg);
        emit MASM::Or32(lhsReg, scratchReg);
        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
    }

    op Int32BitXorResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Id(lhsId);
        let rhsReg = CacheIR::useInt32Id(rhsId);

        let scratchReg = CacheIR::allocateReg();
        emit MASM::Move(rhsReg, scratchReg);
        emit MASM::Xor32(lhsReg, scratchReg);
        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
    }

    op Int32BitAndResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Id(lhsId);
        let rhsReg = CacheIR::useInt32Id(rhsId);

        let scratchReg = CacheIR::allocateReg();
        emit MASM::Move(rhsReg, scratchReg);
        emit MASM::And32(lhsReg, scratchReg);
        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
    }

    op Int32LeftShiftResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Id(lhsId);
        let rhsReg = CacheIR::useInt32Id(rhsId);

        let scratchReg = CacheIR::allocateReg();
        emit MASM::Move(lhsReg, scratchReg);
        emit MASM::FlexibleLshift32(rhsReg, scratchReg);
        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
    }

    op Int32RightShiftResult(lhsId: Int32Id, rhsId: Int32Id) {
        let lhsReg = CacheIR::useInt32Id(lhsId);
        let rhsReg = CacheIR::useInt32Id(rhsId);

        let scratchReg = CacheIR::allocateReg();
        emit MASM::Move(lhsReg, scratchReg);
        emit MASM::FlexibleRshift32Arithmetic(rhsReg, scratchReg);
        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
    }

    op Int32URightShiftResult(lhsId: Int32Id, rhsId: Int32Id, forceDouble: Bool) {
        let lhsReg = CacheIR::useInt32Id(lhsId);
        let rhsReg = CacheIR::useInt32Id(rhsId);
        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::Move(lhsReg, scratchReg);
        emit MASM::FlexibleRshift32(rhsReg, scratchReg);

        if forceDouble {
            let fpscratch = CacheIR::allocateDoubleScratchReg();

            emit MASM::ConvertUInt32ToDouble(scratchReg, fpscratch);
            emit MASM::BoxDouble(fpscratch, TypedOrValueReg::toValueReg(CacheIR::outputReg), fpscratch);

            CacheIR::releaseDoubleScratchReg();
        } else {
            emit MASM::BranchTest32(Condition::Signed, scratchReg, scratchReg, failure.label_);
            emit MASM::TagValue(JSValueType::Int32, scratchReg,
                    TypedOrValueReg::toValueReg(CacheIR::outputReg));
        }

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op Int32NegationResult(inputId: Int32Id) {
        let inputReg = CacheIR::useInt32Id(inputId);
        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::BranchTest32Imm(Condition::Zero, inputReg, 2147483647_i32, failure.label_);
        emit MASM::Move(inputReg, scratchReg);
        emit MASM::Neg32(scratchReg);
        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op Int32IncResult(inputId: Int32Id) {
        let inputReg = CacheIR::useInt32Id(inputId);
        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::Move(inputReg, scratchReg);
        emit MASM::BranchAdd32Imm(Condition::Overflow, 1_i32, scratchReg, failure.label_);
        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op Int32DecResult(inputId: Int32Id) {
        let inputReg = CacheIR::useInt32Id(inputId);
        let scratchReg = CacheIR::allocateReg();

        let failure = CacheIR::addFailurePath();

        emit MASM::Move(inputReg, scratchReg);
        emit MASM::BranchSub32Imm(Condition::Overflow, 1_i32, scratchReg, failure.label_);
        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
        CacheIR::releaseFailurePath();
    }

    op Int32NotResult(inputId: Int32Id) {
        let inputReg = CacheIR::useInt32Id(inputId);
        let scratchReg = CacheIR::allocateReg();

        emit MASM::Move(inputReg, scratchReg);
        emit MASM::Not32(scratchReg);
        emit MASM::TagValue(JSValueType::Int32, scratchReg,
                TypedOrValueReg::toValueReg(CacheIR::outputReg));

        CacheIR::releaseReg(scratchReg);
    }

    op Int32MinMax(isMax: Bool, firstId: Int32Id, secondId: Int32Id, resultId: Int32Id) {
        let firstReg = CacheIR::useInt32Id(firstId);
        let secondReg = CacheIR::useInt32Id(secondId);
        let resultReg = CacheIR::defineInt32Id(resultId);

        emit MASM::Move32Int32(firstReg, resultReg);
        if isMax {
            emit MASM::Cmp32Move32(Condition::GreaterThan, secondReg,
                firstReg, secondReg, resultReg);
        } else {
            emit MASM::Cmp32Move32(Condition::LessThan, secondReg,
                firstReg, secondReg, resultReg);
        }
    }

    fn emitStoreBool(b: Bool, outputReg: TypedOrValueReg) emits MASM {
        if TypedOrValueReg::hasValue(outputReg) {
            let value = Value::fromBool(b);
            emit MASM::MoveValueImm(value, TypedOrValueReg::toValueReg(outputReg));
        } else {
            assert TypedOrValueReg::type(outputReg) == MIRType::Boolean;
            let anyReg = TypedOrValueReg::toTypedReg(outputReg);
            let reg = AnyReg::toReg(anyReg);
            emit MASM::MovePtrBoolImmWord(b, reg);
        }
    }

    // #ifdef DEBUG
    var mut addedFailurePath: Bool;
    // #endif

    fn addFailurePath() -> FailurePath {
        // #ifdef DEBUG
        assert !CacheIR::addedFailurePath;
        CacheIR::addedFailurePath = true;
        // #endif
        unsafe { CacheIR::addFailurePathUnchecked() }
    }
    unsafe fn addFailurePathUnchecked() -> FailurePath;

    fn releaseFailurePath() {
        // #ifdef DEBUG
        assert CacheIR::addedFailurePath;
        CacheIR::addedFailurePath = false;
        // #endif
    }

    fn hasAvailableReg() -> Bool;
    fn isAllocatedValueReg(valueReg: ValueReg) -> Bool;
    fn isAllocatedReg(reg: Reg) -> Bool;

    #[spec]
    fn isAllocatableReg(reg: Reg) -> Bool {
        // NOTE: rbp is allocatable in the latest versions of Firefox, but is not in
        // the current Cachet fork.
        reg != Reg::Rsp &&
        reg != Reg::Rbp &&
        reg != Reg::R11
    }

    fn allocateValueReg() -> ValueReg;
    fn releaseValueReg(valueReg: ValueReg);

    fn allocateReg() -> Reg;
    fn releaseReg(reg: Reg);

    // SAFETY: This does not check that `reg` is an allocatable register, nor
    // does it care about failure paths.
    unsafe fn allocateKnownReg(reg: Reg);

    // Register allocated by ScratchScope

    #[refined]
    fn allocateScratchReg() -> Reg {
        // SAFETY: We're intentionally allocating the scratch register, which is
        // not normally allocatable. This route also intentionally ignores
        // failure paths.
        // TODO(spinda): Replace this with a simple bool, like
        // `isDoubleScratchRegAllocated`.
        unsafe { CacheIR::allocateKnownReg(Reg::scratchReg()); }
        Reg::scratchReg()
    }

    #[refined]
    fn releaseScratchReg() {
        CacheIR::releaseReg(Reg::scratchReg());
    }

    var mut hasAutoScratchFloatRegisterSpill: Bool;
    fn setHasAutoScratchFloatRegisterSpill(hasAutoScratchFloatRegisterSpill: Bool) {
        assert CacheIR::hasAutoScratchFloatRegisterSpill != hasAutoScratchFloatRegisterSpill;
        CacheIR::hasAutoScratchFloatRegisterSpill = hasAutoScratchFloatRegisterSpill;
    }

    // Register allocated by AutoScratchFloatRegister
    fn allocateFloatScratchReg() emits MASM -> FloatReg {
        emit MASM::PushFloatReg(FloatReg::floatReg0());
        CacheIR::setHasAutoScratchFloatRegisterSpill(true);
        FloatReg::floatReg0()
    }

    fn releaseFloatScratchReg() emits MASM {
        emit MASM::PopFloatReg(FloatReg::floatReg0());
        CacheIR::setHasAutoScratchFloatRegisterSpill(false);
    }

    fn allocateFloatScratchRegWithFailurePath(failure: FailurePath) emits MASM -> FloatReg {
        let floatReg = CacheIR::allocateFloatScratchReg();
        FailurePath::setHasAutoScratchFloatRegister(failure);
        floatReg
    }

    fn releaseFloatScratchRegWithFailurePath(
        failure: FailurePath, out label failurePopReg: MASM
    ) emits MASM {
        CacheIR::releaseFloatScratchReg();
        FailurePath::clearHasAutoScratchFloatRegister(failure);

        label done: MASM;
        emit MASM::Jump(done);
        bind failurePopReg;
        emit MASM::PopFloatReg(FloatReg::floatReg0());
        emit MASM::Jump(failure.label_);
        bind done;
    }

    // Register allocated by ScratchDoubleScope

    #[spec]
    var mut isDoubleScratchRegAllocated: Bool;

    #[refined]
    fn allocateDoubleScratchReg() -> FloatReg {
        assert !CacheIR::isDoubleScratchRegAllocated;
        CacheIR::isDoubleScratchRegAllocated = true;
        FloatReg::doubleScratchReg()
    }

    #[refined]
    fn releaseDoubleScratchReg() {
        assert CacheIR::isDoubleScratchRegAllocated;
        CacheIR::isDoubleScratchRegAllocated = false;
    }

    fn defineValueId(valueId: ValueId) -> ValueReg;
    fn defineTypedId(typedId: TypedId) -> Reg;

    #[refined]
    fn defineObjectId(id: ObjectId) -> Reg {
        let typedId = TypedId::fromObjectId(id);
        CacheIR::defineTypedId(typedId)
    }

    #[refined]
    fn defineInt32Id(id: Int32Id) -> Reg {
        let typedId = TypedId::fromInt32Id(id);
        CacheIR::defineTypedId(typedId)
    }

    #[refined]
    fn defineNumberId(id: NumberId) -> ValueReg {
        let valueId = id as ValueId;
        CacheIR::defineValueId(valueId)
    }

    #[refined]
    fn defineBoolId(id: BoolId) -> Reg {
        let typedId = TypedId::fromBoolId(id);
        CacheIR::defineTypedId(typedId)
    }

    #[refined]
    fn defineStringId(id: StringId) -> Reg {
        let typedId = TypedId::fromStringId(id);
        CacheIR::defineTypedId(typedId)
    }

    #[refined]
    fn defineSymbolId(id: SymbolId) -> Reg {
        let typedId = TypedId::fromSymbolId(id);
        CacheIR::defineTypedId(typedId)
    }

    #[refined]
    fn defineBigIntId(id: BigIntId) -> Reg {
        let typedId = TypedId::fromBigIntId(id);
        CacheIR::defineTypedId(typedId)
    }

    #[refined]
    fn defineValueTagId(id: ValueTagId) -> Reg {
        let typedId = TypedId::fromValueTagId(id);
        CacheIR::defineTypedId(typedId)
    }

    fn getOperandLocation(id: OperandId) -> OperandLocation;
    fn setOperandLocation(id: OperandId, loc: OperandLocation);

    #[refined]
    fn knownType(valueId: ValueId) -> JSValueType {
        let operandId = valueId as OperandId;
        let location = CacheIR::getOperandLocation(operandId);
        let locationKind = OperandLocation::kind(location);

        assert locationKind == OperandLocationKind::ValueReg ||
               locationKind == OperandLocationKind::PayloadReg ||
               locationKind == OperandLocationKind::FloatReg;
        if locationKind == OperandLocationKind::PayloadReg {
            return OperandLocation::getPayloadType(location);
        } else if locationKind == OperandLocationKind::FloatReg {
            return JSValueType::Double;
        } else {
            return JSValueType::Unknown;
        }
    }

    #[refined]
    fn useValueId(valueId: ValueId) emits MASM -> ValueReg {
        // #ifdef DEBUG
        assert !CacheIR::addedFailurePath;
        // #endif
        assert !CacheIR::hasAutoScratchFloatRegisterSpill;

        let operandId = valueId as OperandId;
        let location = CacheIR::getOperandLocation(operandId);
        let locationKind = OperandLocation::kind(location);

        if locationKind == OperandLocationKind::ValueReg {
            return OperandLocation::getValueReg(location);
        } else if locationKind == OperandLocationKind::PayloadReg {
            let reg = OperandLocation::getPayloadReg(location);
            let valTy = OperandLocation::getPayloadType(location);
            let valueReg = CacheIR::allocateValueReg();
            emit MASM::TagValue(valTy, reg, valueReg);
            OperandLocation::setValueReg(out location, valueReg);
            CacheIR::releaseReg(reg);
            return valueReg;
        } else {
            assert false;
        }

        OperandLocation::getValueReg(location)
    }

    #[refined]
    fn useTypedId(id: TypedId) emits MASM -> Reg {
        // #ifdef DEBUG
        assert !CacheIR::addedFailurePath;
        // #endif
        assert !CacheIR::hasAutoScratchFloatRegisterSpill;

        let operandId = id as OperandId;
        let location = CacheIR::getOperandLocation(operandId);
        let locationKind = OperandLocation::kind(location);

        if locationKind == OperandLocationKind::PayloadReg {
            return OperandLocation::getPayloadReg(location);
        } else if locationKind == OperandLocationKind::ValueReg {
            let valueReg = OperandLocation::getValueReg(location);
            CacheIR::releaseValueReg(valueReg);
            let reg = ValueReg::scratchReg(valueReg);
            // safe because we know valueReg was previously allocated with
            // allocateValueReg and is allocatable
            unsafe { CacheIR::allocateKnownReg(reg); }
            emit MASM::UnboxNonDouble(valueReg, reg, TypedId::type(id));
            OperandLocation::setPayloadReg(out location, reg, TypedId::type(id));
            CacheIR::setOperandLocation(operandId, location);
            return reg;
        } else {
            assert false;
        }

        OperandLocation::getPayloadReg(location)
    }

    #[refined]
    fn useObjectId(id: ObjectId) emits MASM -> Reg {
        let typedId = TypedId::fromObjectId(id);
        CacheIR::useTypedId(typedId)
    }

    #[refined]
    fn useInt32Id(id: Int32Id) emits MASM -> Reg {
        let typedId = TypedId::fromInt32Id(id);
        CacheIR::useTypedId(typedId)
    }

    #[refined]
    fn useNumberId(id: NumberId) emits MASM -> ValueReg {
        let valueId = id as ValueId;
        CacheIR::useValueId(valueId)
    }

    #[refined]
    fn useBoolId(id: BoolId) emits MASM -> Reg {
        let typedId = TypedId::fromBoolId(id);
        CacheIR::useTypedId(typedId)
    }

    #[refined]
    fn useStringId(id: StringId) emits MASM -> Reg {
        let typedId = TypedId::fromStringId(id);
        CacheIR::useTypedId(typedId)
    }

    #[refined]
    fn useSymbolId(id: SymbolId) emits MASM -> Reg {
        let typedId = TypedId::fromSymbolId(id);
        CacheIR::useTypedId(typedId)
    }

    #[refined]
    fn useBigIntId(id: BigIntId) emits MASM -> Reg {
        let typedId = TypedId::fromBigIntId(id);
        CacheIR::useTypedId(typedId)
    }

    #[refined]
    fn useValueTagId(id: ValueTagId) emits MASM -> Reg {
        let typedId = TypedId::fromValueTagId(id);
        CacheIR::useTypedId(typedId)
    }

    #[refined]
    fn ensureDoubleRegister(id: NumberId, destReg: FloatReg) emits MASM {
        let operandId = id as OperandId;
        let location = CacheIR::getOperandLocation(operandId);
        let locationKind = OperandLocation::kind(location);

        label failure: MASM;
        label done: MASM;

        if locationKind == OperandLocationKind::ValueReg {
            let valueReg = OperandLocation::getValueReg(location);
            emit MASM::EnsureDouble(valueReg, destReg, failure);
        } else if locationKind == OperandLocationKind::FloatReg {
            let floatReg = OperandLocation::getFloatReg(location);
            emit MASM::MoveDouble(floatReg, destReg);
            return;
        } else if locationKind == OperandLocationKind::PayloadReg {
            let payloadType = OperandLocation::getPayloadType(location);
            assert payloadType == JSValueType::Int32;
            let payloadReg = OperandLocation::getPayloadReg(location);
            emit MASM::ConvertInt32ToDouble(payloadReg, destReg);
            return;
        } else {
            assert false;
            return;
        }

        emit MASM::Jump(done);
        bind failure;
        emit MASM::AssumeUnreachable();
        bind done;
    }

    var outputReg: TypedOrValueReg;

    fn emitStoreResult(reg: Reg, type: JSValueType, outputReg: TypedOrValueReg) emits MASM {
        if TypedOrValueReg::hasValue(outputReg) {
            emit MASM::TagValue(type, reg, TypedOrValueReg::toValueReg(outputReg));
            return;
        }

        if type == JSValueType::Int32 && AnyReg::isFloat(TypedOrValueReg::toTypedReg(outputReg)) {
            emit MASM::ConvertInt32ToDouble(reg,
                    AnyReg::toFloatReg(TypedOrValueReg::toTypedReg(outputReg)));
            return;
        }

        if type == JSValueType::fromMIRType(TypedOrValueReg::type(outputReg)) {
            emit MASM::Move(reg, AnyReg::toReg(TypedOrValueReg::toTypedReg(outputReg)));
            return;
        }

        emit MASM::AssumeUnreachable();
    }

    #[refined]
    fn emitLoadInt32StubField(int32Field: Int32Field, dstReg: Reg) emits MASM {
       emit MASM::Move32Int32Imm(CacheIR::readInt32Field(int32Field), dstReg);
    }

    #[refined]
    fn emitLoadValueStubField(valueField: ValueField, dstReg: ValueReg) emits MASM {
       emit MASM::MoveValueImm(CacheIR::readValueField(valueField), dstReg);
    }

    #[refined]
    fn emitLoadObjectStubField(objectField: ObjectField, dstReg: Reg) emits MASM {
        emit MASM::MovePtrImmGCPtrObject(CacheIR::readObjectField(objectField), dstReg);
    }

    fn readInt32Field(int32Field: Int32Field) -> Int32;
    fn readObjectField(objectField: ObjectField) -> Object;
    fn readStringField(stringField: StringField) -> String;
    fn readShapeField(shapeField: ShapeField) -> Shape;
    fn readClassField(classField: ClassField) -> Class;
    fn readInt64Field(int64Field: Int64Field) -> Int64;
    fn readValueField(valueField: ValueField) -> Value;

    fn objectGuardNeedsSpectreMitigations(objectId: ObjectId) -> Bool;

    var mut liveFloatRegSet: FloatRegSet;

    fn liveVolatileFloatRegs() -> FloatRegSet {
        FloatRegSet::intersect(CacheIR::liveFloatRegSet, FloatRegSet::volatile())
    }
}

//spec struct RegAllocState;

//impl CacheIR {
    //spec var mut regAllocState: RegAllocState;

    //spec var mut allocatedRegs: Set<Reg>;
    //spec var mut allocatedValueRegs: Set<ValueReg>;

    //#[reads(CacheIR::regAllocState)]
    //#[writes(CacheIR::regAllocState)]
    //fn allocateReg() -> Reg;

    //refine fn allocateReg() -> Reg {
        //let reg = raw CacheIR::allocateReg();
        //assume !Set::contains(CacheIR::allocatedRegs, reg);
        //CacheIR::allocatedRegs = Set::add(CacheIR::allocatedRegs, reg);
        //reg
    //}

    //#[writes(CacheIR::regAllocState)]
    //fn releaseReg(reg: Reg);

    //refine fn releaseReg(reg: Reg) {
        //raw CacheIR::releaseReg(reg);
        //CacheIR::allocatedRegs = Set::remove(CacheIR::allocatedRegs, reg);
    //}

    //#[reads(CacheIR::regAllocState)]
    //#[writes(CacheIR::regAllocState)]
    //fn allocateValueReg() -> ValueReg;

    //refine fn allocateValueReg() -> ValueReg {
        //let valueReg = raw CacheIR::allocateValueReg();
        //assume !Set::contains(CacheIR::allocatedValueRegs, valueReg);
        //CacheIR::allocatedValueRegs = Set::add(CacheIR::allocatedValueRegs, valueReg);
        //valueReg
    //}

    //#[writes(CacheIR::regAllocState)]
    //fn releaseValueReg(valueReg: ValueReg);

    //refine fn releaseValueReg(valueReg: ValueReg) {
        //raw CacheIR::releaseValueReg(valueReg);
        //CacheIR::allocatedValueRegs = Set::remove(CacheIR::allocatedValueRegs, valueReg);
    //}
//}

// interpreter version:
//ir CacheIR {
    //op LoadInstanceOfObjectResult(lhsId: ValueId, protoId: ObjectId) {
        //CacheIR::getFailurePath(out label failure);

        //let lhs = CacheIR::getValue(lhsId);
        //let proto = CacheIR::getObject(protoId);

        //if !Value::isObject(lhs) {
            //goto failure;
        //}
        //let mut currentObject = Value::toObject(lhs);
        //let mut currentProto = Object::getProto(currentObject);

        //loop {
            //if Value::isNull(currentProto) {
                //CacheIR::setOutput(Value::fromBool(false));
                //return;
            //}
            //if Value::isMagic(currentProto) {
                //goto failure;
            //}

            //if !Value::isObject(currentProto) {
                //CacheIR::setOutput(Value::fromBool(false));
                //return;
            //}
            //currentObject = Value::toObject(currentProto);
            //if currentObject == proto {
                //CacheIR::setOutput(Value::fromBool(true));
                //return;
            //}

            //currentProto = Object::getProto(currentObject);
        //}
    //}
//}
