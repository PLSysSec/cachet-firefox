# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# This script generates jit/CacheIRGenerated.h from CacheIR.yaml and
# jit/CacheIROpsGenerated.h from CacheIROps.yaml.

import buildconfig
import yaml
import re
import six
import textwrap
from collections import OrderedDict
from mozbuild.preprocessor import Preprocessor

HEADER_TEMPLATE = """\
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#ifndef %(includeguard)s
#define %(includeguard)s

/* This file is generated by jit/GenerateCacheIRFiles.py. Do not edit! */

%(contents)s

#endif // %(includeguard)s
"""


def generate_header(c_out, includeguard, contents):
    c_out.write(
        HEADER_TEMPLATE
        % {
            "includeguard": includeguard,
            "contents": contents,
        }
    )


def load_yaml(yaml_path):
    # First invoke preprocessor.py so that we can use #ifdef JS_SIMULATOR in
    # the YAML file.
    pp = Preprocessor()
    pp.context.update(buildconfig.defines["ALLDEFINES"])
    pp.out = six.StringIO()
    pp.do_filter("substitution")
    pp.do_include(yaml_path)
    contents = pp.out.getvalue()

    # Load into an OrderedDict to ensure order is preserved. Note: Python 3.7+
    # also preserves ordering for normal dictionaries.
    # Code based on https://stackoverflow.com/a/21912744.
    class OrderedLoader(yaml.Loader):
        pass

    def construct_mapping(loader, node):
        loader.flatten_mapping(node)
        return OrderedDict(loader.construct_pairs(node))

    tag = yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG
    OrderedLoader.add_constructor(tag, construct_mapping)
    return yaml.load(contents, OrderedLoader)


# Information describing the CacheIR operand types. Tuple stores the C++ type,
# the MIR type, the JS Value type, and whether or not the type is garbage
# collected.
operand_type_info = OrderedDict(
    ValueTag=("JSValueTag", "MIRType::Int32", "JSVAL_TYPE_UNKNOWN", False),
    IntPtr=("intptr_t", "MIRType::IntPtr", "JSVAL_TYPE_UNKNOWN", False),
    Boolean=("bool", "MIRType::Boolean", "JSVAL_TYPE_BOOLEAN", False),
    Int32=("int32_t", "MIRType::Int32", "JSVAL_TYPE_INT32", False),
    Val=("Value", "MIRType::Value", "JSVAL_TYPE_UNKNOWN", True),
    Obj=("JSObject*", "MIRType::Object", "JSVAL_TYPE_OBJECT", True),
    String=("JSString*", "MIRType::String", "JSVAL_TYPE_STRING", True),
    Symbol=("JS::Symbol*", "MIRType::Symbol", "JSVAL_TYPE_SYMBOL", True),
    BigInt=("BigInt*", "MIRType::BigInt", "JSVAL_TYPE_BIGINT", True),
)


# Information for generating CacheIRWriter code for a single argument. Tuple
# stores the C++ argument type and the CacheIRWriter method to call.
arg_writer_info = {
    "ValId": ("ValOperandId", "writeOperandId"),
    "ObjId": ("ObjOperandId", "writeOperandId"),
    "StringId": ("StringOperandId", "writeOperandId"),
    "SymbolId": ("SymbolOperandId", "writeOperandId"),
    "BooleanId": ("BooleanOperandId", "writeOperandId"),
    "Int32Id": ("Int32OperandId", "writeOperandId"),
    "NumberId": ("NumberOperandId", "writeOperandId"),
    "BigIntId": ("BigIntOperandId", "writeOperandId"),
    "ValueTagId": ("ValueTagOperandId", "writeOperandId"),
    "IntPtrId": ("IntPtrOperandId", "writeOperandId"),
    "RawId": ("OperandId", "writeOperandId"),
    "ShapeField": ("Shape*", "writeShapeField"),
    "GetterSetterField": ("GetterSetter*", "writeGetterSetterField"),
    "ObjectField": ("JSObject*", "writeObjectField"),
    "StringField": ("JSString*", "writeStringField"),
    "AtomField": ("JSAtom*", "writeStringField"),
    "PropertyNameField": ("PropertyName*", "writeStringField"),
    "SymbolField": ("JS::Symbol*", "writeSymbolField"),
    "BaseScriptField": ("BaseScript*", "writeBaseScriptField"),
    "RawInt32Field": ("uint32_t", "writeRawInt32Field"),
    "RawPointerField": ("const void*", "writeRawPointerField"),
    "IdField": ("jsid", "writeIdField"),
    "ValueField": ("const Value&", "writeValueField"),
    "RawInt64Field": ("uint64_t", "writeRawInt64Field"),
    "AllocSiteField": ("gc::AllocSite*", "writeAllocSiteField"),
    "JSOpImm": ("JSOp", "writeJSOpImm"),
    "BoolImm": ("bool", "writeBoolImm"),
    "ByteImm": ("uint32_t", "writeByteImm"),  # uint32_t to enable fits-in-byte asserts.
    "GuardClassKindImm": ("GuardClassKind", "writeGuardClassKindImm"),
    "ValueTypeImm": ("ValueType", "writeValueTypeImm"),
    "JSWhyMagicImm": ("JSWhyMagic", "writeJSWhyMagicImm"),
    "CallFlagsImm": ("CallFlags", "writeCallFlagsImm"),
    "ScalarTypeImm": ("Scalar::Type", "writeScalarTypeImm"),
    "UnaryMathFunctionImm": ("UnaryMathFunction", "writeUnaryMathFunctionImm"),
    "WasmValTypeImm": ("wasm::ValType::Kind", "writeWasmValTypeImm"),
    "Int32Imm": ("int32_t", "writeInt32Imm"),
    "UInt32Imm": ("uint32_t", "writeUInt32Imm"),
    "JSNativeImm": ("JSNative", "writeJSNativeImm"),
    "StaticStringImm": ("const char*", "writeStaticStringImm"),
    "AllocKindImm": ("gc::AllocKind", "writeAllocKindImm"),
}


def gen_writer_method(name, args, custom_writer):
    """Generates a CacheIRWRiter method for a single opcode."""

    # Generate a single method that writes the opcode and each argument.
    # For example:
    #
    #   void guardShape(ObjOperandId obj, Shape* shape) {
    #     writeOp(CacheOp::GuardShape);
    #     writeOperandId(obj);
    #     writeShapeField(shape);
    #     assertLengthMatches();
    #  }
    #
    # The assertLengthMatches() call is to assert the information in the
    # arg_length dictionary below matches what's written.

    # Method names start with a lowercase letter.
    method_name = name[0].lower() + name[1:]
    if custom_writer:
        method_name += "_"

    method_args = []
    ret_type = "void"
    args_code = ""
    if args:
        for arg_name, arg_type in six.iteritems(args):
            cpp_type, write_method = arg_writer_info[arg_type]
            if arg_name == "result":
                ret_type = cpp_type
                args_code += "  {} result(newOperandId());\\\n".format(cpp_type)
                args_code += "  writeOperandId(result);\\\n"
            else:
                method_args.append("{} {}".format(cpp_type, arg_name))
                args_code += "  {}({});\\\n".format(write_method, arg_name)

    code = ""
    if custom_writer:
        code += "private:\\\n"
    code += "{} {}({}) {{\\\n".format(ret_type, method_name, ", ".join(method_args))
    code += "  writeOp(CacheOp::{});\\\n".format(name)
    code += args_code
    code += "  assertLengthMatches();\\\n"
    if ret_type != "void":
        code += "  return result;\\\n"
    code += "}"
    if custom_writer:
        code += "\\\npublic:"
    return code


# Information for generating code using CacheIRReader for a single argument.
# Tuple stores the C++ type, the suffix used for arguments/variables of this
# type, and the expression to read this type from CacheIRReader.
arg_reader_info = {
    "ValId": ("ValOperandId", "Id", "reader.valOperandId()"),
    "ObjId": ("ObjOperandId", "Id", "reader.objOperandId()"),
    "StringId": ("StringOperandId", "Id", "reader.stringOperandId()"),
    "SymbolId": ("SymbolOperandId", "Id", "reader.symbolOperandId()"),
    "BooleanId": ("BooleanOperandId", "Id", "reader.booleanOperandId()"),
    "Int32Id": ("Int32OperandId", "Id", "reader.int32OperandId()"),
    "NumberId": ("NumberOperandId", "Id", "reader.numberOperandId()"),
    "BigIntId": ("BigIntOperandId", "Id", "reader.bigIntOperandId()"),
    "ValueTagId": ("ValueTagOperandId", "Id", "reader.valueTagOperandId()"),
    "IntPtrId": ("IntPtrOperandId", "Id", "reader.intPtrOperandId()"),
    "RawId": ("uint32_t", "Id", "reader.rawOperandId()"),
    "ShapeField": ("uint32_t", "Offset", "reader.stubOffset()"),
    "GetterSetterField": ("uint32_t", "Offset", "reader.stubOffset()"),
    "ObjectField": ("uint32_t", "Offset", "reader.stubOffset()"),
    "StringField": ("uint32_t", "Offset", "reader.stubOffset()"),
    "AtomField": ("uint32_t", "Offset", "reader.stubOffset()"),
    "PropertyNameField": ("uint32_t", "Offset", "reader.stubOffset()"),
    "SymbolField": ("uint32_t", "Offset", "reader.stubOffset()"),
    "BaseScriptField": ("uint32_t", "Offset", "reader.stubOffset()"),
    "RawInt32Field": ("uint32_t", "Offset", "reader.stubOffset()"),
    "RawPointerField": ("uint32_t", "Offset", "reader.stubOffset()"),
    "IdField": ("uint32_t", "Offset", "reader.stubOffset()"),
    "ValueField": ("uint32_t", "Offset", "reader.stubOffset()"),
    "RawInt64Field": ("uint32_t", "Offset", "reader.stubOffset()"),
    "AllocSiteField": ("uint32_t", "Offset", "reader.stubOffset()"),
    "JSOpImm": ("JSOp", "", "reader.jsop()"),
    "BoolImm": ("bool", "", "reader.readBool()"),
    "ByteImm": ("uint8_t", "", "reader.readByte()"),
    "GuardClassKindImm": ("GuardClassKind", "", "reader.guardClassKind()"),
    "ValueTypeImm": ("ValueType", "", "reader.valueType()"),
    "JSWhyMagicImm": ("JSWhyMagic", "", "reader.whyMagic()"),
    "CallFlagsImm": ("CallFlags", "", "reader.callFlags()"),
    "ScalarTypeImm": ("Scalar::Type", "", "reader.scalarType()"),
    "UnaryMathFunctionImm": ("UnaryMathFunction", "", "reader.unaryMathFunction()"),
    "WasmValTypeImm": ("wasm::ValType::Kind", "", "reader.wasmValType()"),
    "Int32Imm": ("int32_t", "", "reader.int32Immediate()"),
    "UInt32Imm": ("uint32_t", "", "reader.uint32Immediate()"),
    "JSNativeImm": ("JSNative", "", "reinterpret_cast<JSNative>(reader.pointer())"),
    "StaticStringImm": ("const char*", "", "reinterpret_cast<char*>(reader.pointer())"),
    "AllocKindImm": ("gc::AllocKind", "", "reader.allocKind()"),
}


def gen_compiler_method(name, args):
    """Generates CacheIRCompiler or WarpCacheIRTranspiler header code for a
    single opcode."""

    method_name = "emit" + name

    # We generate the signature of the method that needs to be implemented and a
    # separate function forwarding to it. For example:
    #
    #   [[nodiscard]] bool emitGuardShape(ObjOperandId objId, uint32_t shapeOffset);
    #   [[nodiscard]] bool emitGuardShape(CacheIRReader& reader) {
    #     ObjOperandId objId = reader.objOperandId();
    #     uint32_t shapeOffset = reader.stubOffset();
    #     return emitGuardShape(objId, shapeOffset);
    #   }
    cpp_args = []
    method_args = []
    args_code = ""
    if args:
        for arg_name, arg_type in six.iteritems(args):
            cpp_type, suffix, readexpr = arg_reader_info[arg_type]
            cpp_name = arg_name + suffix
            cpp_args.append(cpp_name)
            method_args.append("{} {}".format(cpp_type, cpp_name))
            args_code += "  {} {} = {};\\\n".format(cpp_type, cpp_name, readexpr)

    # Generate signature.
    code = "[[nodiscard]] bool {}({});\\\n".format(method_name, ", ".join(method_args))

    # Generate the method forwarding to it.
    code += "[[nodiscard]] bool {}(CacheIRReader& reader) {{\\\n".format(method_name)
    code += args_code
    code += "  return {}({});\\\n".format(method_name, ", ".join(cpp_args))
    code += "}\\\n"

    return code


# For each argument type, the method name for printing it.
arg_spewer_method = {
    "ValId": "spewOperandId",
    "ObjId": "spewOperandId",
    "StringId": "spewOperandId",
    "SymbolId": "spewOperandId",
    "BooleanId": "spewOperandId",
    "Int32Id": "spewOperandId",
    "NumberId": "spewOperandId",
    "BigIntId": "spewOperandId",
    "ValueTagId": "spewOperandId",
    "IntPtrId": "spewOperandId",
    "RawId": "spewRawOperandId",
    "ShapeField": "spewField",
    "GetterSetterField": "spewField",
    "ObjectField": "spewField",
    "StringField": "spewField",
    "AtomField": "spewField",
    "PropertyNameField": "spewField",
    "SymbolField": "spewField",
    "BaseScriptField": "spewField",
    "RawInt32Field": "spewField",
    "RawPointerField": "spewField",
    "IdField": "spewField",
    "ValueField": "spewField",
    "RawInt64Field": "spewField",
    "AllocSiteField": "spewField",
    "JSOpImm": "spewJSOpImm",
    "BoolImm": "spewBoolImm",
    "ByteImm": "spewByteImm",
    "GuardClassKindImm": "spewGuardClassKindImm",
    "ValueTypeImm": "spewValueTypeImm",
    "JSWhyMagicImm": "spewJSWhyMagicImm",
    "CallFlagsImm": "spewCallFlagsImm",
    "ScalarTypeImm": "spewScalarTypeImm",
    "UnaryMathFunctionImm": "spewUnaryMathFunctionImm",
    "WasmValTypeImm": "spewWasmValTypeImm",
    "Int32Imm": "spewInt32Imm",
    "UInt32Imm": "spewUInt32Imm",
    "JSNativeImm": "spewJSNativeImm",
    "StaticStringImm": "spewStaticStringImm",
    "AllocKindImm": "spewAllocKindImm",
}


def gen_spewer_method(name, args):
    """Generates spewer code for a single opcode."""

    method_name = "spew" + name

    # Generate code like this:
    #
    #  void spewGuardShape(CacheIRReader& reader) {
    #     spewOp(CacheOp::GuardShape);
    #     spewOperandId("obj", "ObjId", reader.objOperandId());
    #     spewOperandSeparator();
    #     spewField("shape", "ShapeField", reader.stubOffset());
    #     spewOpEnd();
    #  }
    args_code = ""
    if args:
        is_first = True
        for arg_name, arg_type in six.iteritems(args):
            _, _, readexpr = arg_reader_info[arg_type]
            spew_method = arg_spewer_method[arg_type]
            if not is_first:
                args_code += "  spewArgSeparator();\\\n"
            args_code += '  {}("{}", "{}", {});\\\n'.format(
                spew_method, arg_name, arg_type, readexpr
            )
            is_first = False

    code = "void {}(CacheIRReader& reader) {{\\\n".format(method_name)
    code += "  spewOp(CacheOp::{});\\\n".format(name)
    code += args_code
    code += "  spewOpEnd();\\\n"
    code += "}\\\n"

    return code


def gen_clone_method(name, args):
    """Generates code for cloning a single opcode."""

    method_name = "clone" + name

    # Generate code like this:
    #
    #  void cloneGuardShape(CacheIRReader& reader, CacheIRWriter& writer) {
    #    writer.writeOp(CacheOp::GuardShape);
    #    ObjOperandId objId = reader.objOperandId();
    #    writer.writeOperandId(objId);
    #    uint32_t shapeOffset = reader.stubOffset();
    #    Shape* shape = getShapeField(shapeOffset);
    #    writer.writeShapeField(shape);
    #    writer.assertLengthMatches();
    #  }

    args_code = ""
    if args:
        for arg_name, arg_type in six.iteritems(args):
            if arg_type == "RawId":
                arg_type = "ValId"

            read_type, suffix, readexpr = arg_reader_info[arg_type]
            read_name = arg_name + suffix
            value_name = read_name
            args_code += "  {} {} = {};\\\n".format(read_type, read_name, readexpr)

            write_type, write_method = arg_writer_info[arg_type]
            if arg_name == "result":
                args_code += "  writer.newOperandId();\\\n"
            if suffix == "Offset":
                # If the write function takes T&, the intermediate variable
                # should be of type T.
                if write_type.endswith("&"):
                    write_type = write_type[:-1]
                value_name = arg_name
                args_code += "  {} {} = get{}({});\\\n".format(
                    write_type, value_name, arg_type, read_name
                )
            args_code += "  writer.{}({});\\\n".format(write_method, value_name)

    code = "void {}".format(method_name)
    code += "(CacheIRReader& reader, CacheIRWriter& writer) {{\\\n"
    code += "  writer.writeOp(CacheOp::{});\\\n".format(name)
    code += args_code
    code += "  writer.assertLengthMatches();\\\n"
    code += "}}\\\n"

    return code


def gen_kind_signature(name, inputs, output):
    """Generates an element of CacheKindSignatures, mapping out the inputs and
    output of a CacheKind."""

    signature_num_inputs = len(inputs)

    signature_inputs = ",\\\n      ".join(
        f'{{ "{name}", CacheType::{type_} }}' for name, type_ in inputs.items()
    )

    signature_output = "mozilla::" + (
        "Nothing()" if output is None else f"Some(CacheType::{output})"
    )

    return (
        f"  /* {name} = */ {{\\\n"
        f"    /* numInputs = */ {signature_num_inputs},\\\n"
        f"    /* inputs = */ new CacheKindSignature::Input[{signature_num_inputs}] {{\\\n"
        f"      {signature_inputs}\\\n"
        f"    }},\\\n"
        f"    /* output = */ {signature_output}\\\n"
        f"  }},"
        #
    )


pascal_case_re = re.compile(r"^(?P<init>[A-Z]*)(?P<tail>.*)$")


def pascal_to_camel_case(name):
    """Converts a name from PascalCase to camelCase."""

    match = pascal_case_re.match(name)
    return match.group("init").lower() + match.group("tail")


def match_cache_kinds(kinds):
    """Generates switch statement cases matching the given CacheKinds."""

    code = "case CacheKind::"
    code += ":\\\ncase CacheKind::".join(kinds)
    code += ":"
    return code


def gen_ion_init_case(name, kinds, inputs, output, temps):
    """Generates a case for IonCacheIRCompiler::init, setting up locations for
    inputs, output, and temps from an instance of Ion<name>IC."""

    ic_var_name = f"{pascal_to_camel_case(name)}IC"

    code = (
        f"{match_cache_kinds(kinds)} {{\\\n"
        f"  const Ion{name}IC* const {ic_var_name}(ic_->as{name}IC());\\\n"
        f"  liveRegs_.emplace({ic_var_name}->liveRegs());\\\n"
        f"  \\\n"
        #
    )

    # Set up input locations.
    if len(inputs) > 0:
        code += "  size_t i(0);\\\n"

        for input_name, input_data in inputs.items():
            input_type = input_data["type"]
            input_kinds = input_data["kinds"]

            _, mir_type, _, _ = operand_type_info[input_type]

            input_code = f"{ic_var_name}->{input_name}()"

            if input_type != "Val":
                input_code = (
                    f"TypedOrValueRegister({mir_type}, AnyRegister({input_code}))"
                )

            input_code = f"  allocator.initInputLocation(i++, {input_code});\\\n"

            # Some inputs may not be present on all CacheKinds handled by the
            # IonIC.
            if len(input_kinds) < len(kinds):
                input_code = (
                    f"  switch (ic_->kind()) {{\\\n"
                    f"{textwrap.indent(match_cache_kinds(input_kinds), '    ')} {{\\\n"
                    f"{textwrap.indent(input_code, '    ')}"
                    f"      break;\\\n"
                    f"    }}\\\n"
                    f"    default: {{\\\n"
                    f"      break;\\\n"
                    f"    }}\\\n"
                    f"  }}\\\n"
                    #
                )

            code += input_code

        code += "  \\\n"

    # Optionally set up an output location.
    if output is not None:
        code += (
            f"  auto output({ic_var_name}->output());\\\n"
            f"  available.add(output);\\\n"
            f"  outputUnchecked_.emplace("
            #
        )

        if output == "Val":
            code += "output"
        else:
            _, mir_type, _, _ = operand_type_info[output]
            code += f"TypedOrValueRegister({mir_type}, AnyRegister(output))"

        code += (
            ");\\\n"
            "  \\\n"
            #
        )

    # Set up locations for the temps.
    if temps > 0:
        # Use .temp() if the IonIC has just a single temp and .temp<i>()
        # otherwise.
        temps = ["temp"] if temps == 1 else (f"temp{i}" for i in range(1, temps + 1))
        for temp in temps:
            code += f"  available.add({ic_var_name}->{temp}());\\\n"
        code += "  \\\n"

    code += (
        "  break;\\\n"
        "}"
        #
    )

    return code


def gen_ion_fallback_case(name, kinds, inputs, output):
    """Generates a case for IonCacheIRCompiler::init, setting up locations for
    inputs, output, and temps from an instance of Ion<name>IC."""

    ic_var_name = f"{pascal_to_camel_case(name)}IC"

    code = (
        f"{match_cache_kinds(kinds)} {{\\\n"
        f"  Ion{name}IC* const {ic_var_name}(ic->as{name}IC());\\\n"
        f"  \\\n"
        f"  saveLive(lir);\\\n"
        f"  \\\n"
        #
    )

    # Push arguemnts to Ion<name>IC::update onto the stack in reverse order.
    for input_name in reversed(inputs.keys()):
        code += f"  pushArg({ic_var_name}->{input_name}());\\\n"
    code += (
        "  icInfo_[cacheInfoIndex].icOffsetForPush = pushArgWithPatch(ImmWord(-1));\\\n"
        "  pushArg(ImmGCPtr(gen->outerInfo().script()));\\\n"
        "  \\\n"
        #
    )

    # Compute the function signature for Ion<name>IC::update.

    fn_return_cpp_type = "bool"
    fn_out_param_cpp_type = None

    if output is not None:
        cpp_type, _, _, is_gc_type = operand_type_info[output]
        if output == "Obj":
            # Object outputs are returned directly from the update function.
            fn_return_cpp_type = cpp_type
        else:
            # All other outputs are fed through an out-parameter.
            if is_gc_type:
                fn_out_param_cpp_type = f"MutableHandle<{cpp_type}>"
            else:
                fn_out_param_cpp_type = f"{cpp_type}*"

    code += (
        f"  using Fn = {fn_return_cpp_type} (*)(JSContext*, HandleScript, Ion{name}IC*"
    )

    for input_name, input_data in inputs.items():
        input_type = input_data["type"]
        cpp_type, _, _, is_gc_type = operand_type_info[input_type]
        if is_gc_type:
            cpp_type = f"Handle<{cpp_type}>"
        code += f", {cpp_type}"

    if fn_out_param_cpp_type is not None:
        code += f", {fn_out_param_cpp_type}"

    code += ");\\\n"

    # Insert the call to Ion<name>IC::update.
    code += (
        f"  {ic_var_name}->setFallbackCallOffset(callVM<Fn, Ion{name}IC::update>(lir));\\\n"
        f"  \\\n"
        #
    )

    # Restore registers following the call.
    if output is None:
        code += "  restoreLive(lir);\\\n"
    else:
        store_code = f"{ic_var_name}->output()"
        if output == "Val":
            store_code = f"StoreValueTo({store_code})"
        else:
            store_code = f"StoreAnyRegisterTo(AnyRegister({store_code}))"

        code += (
            f"  {store_code}.generate(this);\\\n"
            f"  restoreLiveIgnore(lir, {store_code}.clobbered());\\\n"
            #
        )

    # Jump back into script code.
    code += (
        "  \\\n"
        "  masm.jump(ool->rejoin());\\\n"
        "  break;\\\n"
        "}"
        #
    )

    return code


def gen_shell_generate_ion_stub_case(name, kinds, inputs, output):
    """Generates a case for IonICObject::generateStubMethod in the JS shell,
    extracting inputs from JS argument values and wiring them into
    Ion<name>IC::update."""

    ic_var_name = f"ion{name}IC"

    code = (
        f"{match_cache_kinds(kinds)} {{\\\n"
        f"  Ion{name}IC* const {ic_var_name}(ionIC.as{name}IC());\\\n"
        #
    )

    input_args_code = ""
    if len(inputs) > 0:
        code += (
            "  \\\n"
            "  size_t i(0);\\\n"
            "  \\\n"
            #
        )

        for input_name, input_data in inputs.items():
            input_var_name = f"{input_name}Input"
            input_args_code += f", {input_var_name}"

            input_type = input_data["type"]
            input_kinds = input_data["kinds"]

            cpp_type, _, _, is_gc_type = operand_type_info[input_type]
            if is_gc_type:
                cpp_type = f"Rooted<{cpp_type}>"

            code += f"  {cpp_type} {input_var_name}("
            if is_gc_type:
                code += "cx"
            code += ");\\\n"

            def gen_populate_input_var_code(input_value_code):
                return (
                    f"  if (!ValueToCacheIR{input_type}(cx, {input_value_code}, "
                    f"&{input_var_name})) {{\\\n"
                    f"    return false;\\\n"
                    f"  }}\\\n"
                    #
                )

            populate_input_var_code = gen_populate_input_var_code("args[i++]")

            # Some inputs may not be present on all CacheKinds handled by the
            # IonIC.
            if len(input_kinds) < len(kinds):
                populate_input_var_code = (
                    f"  switch (ionIC.kind()) {{\\\n"
                    f"{textwrap.indent(match_cache_kinds(input_kinds), '    ')} {{\\\n"
                    f"{textwrap.indent(populate_input_var_code, '    ')}"
                    f"      break;\\\n"
                    f"    }}\\\n"
                    f"    default: {{\\\n"
                    f"      const RootedValue constant(cx, "
                    f"{ic_var_name}->{input_name}().value());\\\n"
                    f"{textwrap.indent(gen_populate_input_var_code('constant'), '    ')}"
                    f"      break;\\\n"
                    f"    }}\\\n"
                    f"  }}\\\n"
                    #
                )

            code += populate_input_var_code
            code += "  \\\n"

    if output is None or output == "Obj":
        output_arg_code = ""
    else:
        cpp_type, _, _, is_gc_type = operand_type_info[output]
        if is_gc_type:
            cpp_type = f"Rooted<{cpp_type}>"

        code += f"  {cpp_type} output"
        if is_gc_type:
            code += "(cx)"
        code += ";\\\n"

        output_arg_code = ", &output"

    code += (
        f"  if (!Ion{name}IC::update(cx, script, {ic_var_name}"
        f"{input_args_code}{output_arg_code})) {{\\\n"
        f"    return false;\\\n"
        f"  }}\\\n"
        f"  break;\\\n"
        f"}}"
        #
    )

    return code


# Length in bytes for each argument type, either an integer or a C++ expression.
# This is used to generate the CacheIROpArgLengths array. CacheIRWriter asserts
# the number of bytes written matches the value in that array.
arg_length = {
    "ValId": 1,
    "ObjId": 1,
    "StringId": 1,
    "SymbolId": 1,
    "BooleanId": 1,
    "Int32Id": 1,
    "NumberId": 1,
    "BigIntId": 1,
    "ValueTagId": 1,
    "IntPtrId": 1,
    "RawId": 1,
    "ShapeField": 1,
    "GetterSetterField": 1,
    "ObjectField": 1,
    "StringField": 1,
    "AtomField": 1,
    "PropertyNameField": 1,
    "SymbolField": 1,
    "BaseScriptField": 1,
    "RawInt32Field": 1,
    "RawPointerField": 1,
    "RawInt64Field": 1,
    "IdField": 1,
    "ValueField": 1,
    "AllocSiteField": 1,
    "ByteImm": 1,
    "BoolImm": 1,
    "CallFlagsImm": 1,
    "ScalarTypeImm": 1,
    "UnaryMathFunctionImm": 1,
    "JSOpImm": 1,
    "ValueTypeImm": 1,
    "GuardClassKindImm": 1,
    "JSWhyMagicImm": 1,
    "WasmValTypeImm": 1,
    "Int32Imm": 4,
    "UInt32Imm": 4,
    "JSNativeImm": "sizeof(uintptr_t)",
    "StaticStringImm": "sizeof(uintptr_t)",
    "AllocKindImm": 1,
}


def generate_cacheir_header(c_out, yaml_path):
    """Generate CacheIRGenerated.h from CacheIR.yaml. The generated file
    contains a list of CacheIR types and kinds, and generated source code for
    CodeGenerator, IonCacheIRCompiler, and IonICObject."""

    data = load_yaml(yaml_path)
    cache_kinds = data["cache_kinds"]
    ion_ics = data.get("ion_ics", OrderedDict())

    # CACHE_IR_PRIMITIVE_TYPES and CACHE_IR_GC_TYPES items.
    primitive_types_items = []
    gc_types_items = []

    # Specializations of CacheTypesHelper, which map CacheIR types to C++ types.
    types_helper_specializations = []

    # Generated cases for CacheType conversion.
    mir_type_cases = []
    value_type_cases = []

    # CACHE_IR_KINDS items. Each item stores the name of a CacheKind. For
    # example: _(GetProp)
    kinds_items = []

    # Generated signatures for the available CacheKinds, describing their inputs
    # and outputs.
    kind_signatures = []

    # Generated cases for IonCacheIRCompiler::init.
    ion_init_cases = []

    # Generated cases for CodeGenerator::visitOutOfLineICFallback.
    ion_fallback_cases = []

    # Fall-through cases for CacheKinds not supported by Ion.
    ion_unsupported_cases = []

    # Cases for generating Ion CacheIR stubs via the JS shell.
    shell_generate_ion_stub_cases = []

    for name, (cpp_type, mir_type, value_type, is_gc_type) in operand_type_info.items():
        types_items = gc_types_items if is_gc_type else primitive_types_items
        types_items.append(f"_({name})")

        types_helper_specializations.append(
            f"template <>\\\n"
            f"struct CacheTypesHelper<CacheType::{name}> {{\\\n"
            f"  using Type = {cpp_type};\\\n"
            f"}};"
            #
        )

        mir_type_cases.append(
            f"case CacheType::{name}: {{\\\n"
            f"  return {mir_type};\\\n"
            f"}}"
            #
        )
        value_type_cases.append(
            f"case CacheType::{name}: {{\\\n"
            f"  return {value_type};\\\n"
            f"}}"
            #
        )

    for name, kind in cache_kinds.items():
        inputs = kind.get("inputs", OrderedDict())
        assert all(input_type is not None for input_type in inputs.values())

        output = kind.get("output")
        ion_ic_name = kind.get("ion_ic")

        kinds_items.append(f"_({name})")
        kind_signatures.append(gen_kind_signature(name, inputs, output))

        if ion_ic_name is None:
            ion_unsupported_cases.append(f"case CacheKind::{name}:")
        else:
            ion_ic = ion_ics.get(ion_ic_name)
            if ion_ic is None:
                ion_ic = ion_ics[ion_ic_name] = {}

            ion_ic.setdefault("kinds", []).append(name)

            ion_ic_inputs = ion_ic.get("inputs")
            if ion_ic_inputs is None:
                # If the IonIC doesn't specify its inputs, autopopulate with the
                # inputs of the first CacheKind that points to it.
                ion_ic_inputs = list(inputs.keys())
            if isinstance(ion_ic_inputs, list):
                # Convert from the short list form to dictionary form,
                # marking each input type as initially unknown.
                ion_ic_inputs = ion_ic["inputs"] = OrderedDict(
                    (input_name, {"type": None, "kinds": []})
                    for input_name in ion_ic_inputs
                )

            ion_ic_inputs_iter = ion_ic_inputs.items()
            for input_name, input_type in inputs.items():
                # Find the corresponding IonIC input for each CacheKind
                # input. The order of the CacheKind inputs must match the
                # IonIC, though a CacheKind can omit inputs present in its
                # IonIC.
                for ion_ic_input_name, ion_ic_input in ion_ic_inputs_iter:
                    if ion_ic_input_name == input_name:
                        break
                else:
                    assert False, (
                        f"Can't match input {input_name} on CacheKind {name} with a corresponding "
                        f"input on IonIC {ion_ic_name}"
                    )

                ion_ic_input["kinds"].append(name)

                if ion_ic_input["type"] is None:
                    # Learn IonIC input types from their CacheKinds.
                    ion_ic_input["type"] = input_type
                else:
                    assert input_type == ion_ic_input["type"], (
                        f"Input {input_name} has type {input_type} on CacheKind {name}, but type "
                        f"{ion_ic_input['type']} on IonIC {ion_ic_name}"
                    )

            if "output" in ion_ic:
                ion_ic_output = ion_ic["output"]
                assert output == ion_ic_output, (
                    f"CacheKind {name} has output type {output}, but IonIC {ion_ic_name} has "
                    f"output type {ion_ic_output}"
                )
            else:
                # Learn IonIC output types from their CacheKinds.
                ion_ic["output"] = output

    for name, ion_ic in ion_ics.items():
        inputs = ion_ic["inputs"]
        for input_name, input_type in inputs.items():
            assert (
                input_type is not None
            ), f"Couldn't infer type for input {input_name} on IonIC {name}"

        kinds = ion_ic.get("kinds")
        if kinds is None:
            continue

        output = ion_ic["output"]
        temps = ion_ic.get("temps", 0)

        ion_init_cases.append(gen_ion_init_case(name, kinds, inputs, output, temps))
        ion_fallback_cases.append(gen_ion_fallback_case(name, kinds, inputs, output))
        shell_generate_ion_stub_cases.append(
            gen_shell_generate_ion_stub_case(name, kinds, inputs, output)
        )

    if len(ion_unsupported_cases) > 0:
        ion_unsupported_cases = "\\\n".join(ion_unsupported_cases)
        ion_unsupported_cases = (
            f"\\\n"
            f"{ion_unsupported_cases} {{\\\n"
            f'  MOZ_CRASH("Unsupported IC");\\\n'
            f"}}"
            #
        )
    else:
        ion_unsupported_cases = ""

    contents = "#define CACHE_IR_PRIMITIVE_TYPES(_)\\\n"
    contents += "\\\n".join(primitive_types_items)
    contents += "\n\n"

    contents += "#define CACHE_IR_GC_TYPES(_)\\\n"
    contents += "\\\n".join(gc_types_items)
    contents += "\n\n"

    contents += "#define CACHE_IR_TYPES(_)\\\n"
    contents += "CACHE_IR_PRIMITIVE_TYPES(_)\\\n"
    contents += "CACHE_IR_GC_TYPES(_)"
    contents += "\n\n"

    contents += "#define CACHE_IR_TYPES_HELPER_SPECIALIZATIONS_GENERATED \\\n"
    contents += "\\\n".join(types_helper_specializations)
    contents += "\n\n"

    contents += "#define CACHE_IR_MIR_TYPE_CASES_GENERATED \\\n"
    contents += "\\\n".join(mir_type_cases)
    contents += "\n\n"

    contents += "#define CACHE_IR_VALUE_TYPE_CASES_GENERATED \\\n"
    contents += "\\\n".join(value_type_cases)
    contents += "\n\n"

    contents += "#define CACHE_IR_KINDS(_)\\\n"
    contents += "\\\n".join(kinds_items)
    contents += "\n\n"

    contents += "#define CACHE_IR_KIND_SIGNATURES_GENERATED \\\n"
    contents += "\\\n".join(kind_signatures)
    contents += "\n\n"

    contents += "#define CACHE_IR_ION_INIT_CASES_GENERATED \\\n"
    contents += "\\\n".join(ion_init_cases)
    contents += ion_unsupported_cases
    contents += "\n\n"

    contents += "#define CACHE_IR_ION_FALLBACK_CASES_GENERATED \\\n"
    contents += "\\\n".join(ion_fallback_cases)
    contents += ion_unsupported_cases
    contents += "\n\n"

    contents += "#define CACHE_IR_SHELL_GENERATE_ION_STUB_CASES_GENERATED \\\n"
    contents += "\\\n".join(shell_generate_ion_stub_cases)
    contents += ion_unsupported_cases

    generate_header(c_out, "jit_CacheIRGenerated_h", contents)


def generate_cacheirops_header(c_out, yaml_path):
    """Generate CacheIROpsGenerated.h from CacheIROps.yaml. The generated files
    contains a list of all CacheIR ops, and generated source code for
    CacheIRWriter and CacheIRCompiler."""

    cache_ops = load_yaml(yaml_path)

    # CACHE_IR_OPS items. Each item stores an opcode name and arguments length
    # expression. For example: _(GuardShape, 1 + 1)
    ops_items = []

    # Generated CacheIRWriter methods.
    writer_methods = []

    # Generated CacheIRCompiler methods.
    compiler_shared_methods = []
    compiler_unshared_methods = []

    # Generated WarpCacheIRTranspiler methods.
    transpiler_methods = []

    # List of ops supported by WarpCacheIRTranspiler.
    transpiler_ops = []

    # Generated methods for spewers.
    spewer_methods = []

    # Generated methods for cloning IC stubs
    clone_methods = []

    for name, op in cache_ops.items():
        args = op["args"]
        assert args is None or isinstance(args, OrderedDict)

        shared = op["shared"]
        assert isinstance(shared, bool)

        transpile = op["transpile"]
        assert isinstance(transpile, bool)

        # Unscored Ops default to UINT32_MAX
        cost_estimate = op.get("cost_estimate", int(0xFFFFFFFF))
        assert isinstance(cost_estimate, int)

        custom_writer = op.get("custom_writer", False)
        assert isinstance(custom_writer, bool)

        if args:
            args_length = " + ".join([str(arg_length[v]) for v in args.values()])
        else:
            args_length = "0"

        transpile_str = "true" if transpile else "false"
        ops_items.append(
            "_({}, {}, {}, {})".format(name, args_length, transpile_str, cost_estimate)
        )

        writer_methods.append(gen_writer_method(name, args, custom_writer))

        if shared:
            compiler_shared_methods.append(gen_compiler_method(name, args))
        else:
            compiler_unshared_methods.append(gen_compiler_method(name, args))

        if transpile:
            transpiler_methods.append(gen_compiler_method(name, args))
            transpiler_ops.append("_({})".format(name))

        spewer_methods.append(gen_spewer_method(name, args))

        clone_methods.append(gen_clone_method(name, args))

    contents = "#define CACHE_IR_OPS(_)\\\n"
    contents += "\\\n".join(ops_items)
    contents += "\n\n"

    contents += "#define CACHE_IR_WRITER_GENERATED \\\n"
    contents += "\\\n".join(writer_methods)
    contents += "\n\n"

    contents += "#define CACHE_IR_COMPILER_SHARED_GENERATED \\\n"
    contents += "\\\n".join(compiler_shared_methods)
    contents += "\n\n"

    contents += "#define CACHE_IR_COMPILER_UNSHARED_GENERATED \\\n"
    contents += "\\\n".join(compiler_unshared_methods)
    contents += "\n\n"

    contents += "#define CACHE_IR_TRANSPILER_GENERATED \\\n"
    contents += "\\\n".join(transpiler_methods)
    contents += "\n\n"

    contents += "#define CACHE_IR_TRANSPILER_OPS(_)\\\n"
    contents += "\\\n".join(transpiler_ops)
    contents += "\n\n"

    contents += "#define CACHE_IR_SPEWER_GENERATED \\\n"
    contents += "\\\n".join(spewer_methods)
    contents += "\n\n"

    contents += "#define CACHE_IR_CLONE_GENERATED \\\n"
    contents += "\\\n".join(clone_methods)
    contents += "\n\n"

    generate_header(c_out, "jit_CacheIROpsGenerated_h", contents)
