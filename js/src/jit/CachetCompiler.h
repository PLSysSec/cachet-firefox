/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#ifndef jit_CachetCompiler_h
#define jit_CachetCompiler_h

#include "jit/CacheIR.h"
#include "jit/CachetPrelude.h"
#include "jit/MacroAssembler.h"
#include "js/Class.h"
#include "js/RootingAPI.h"
#include "js/Value.h"
#include "vm/JSObject.h"
#include "vm/NativeObject.h"
#include "vm/Shape.h"

namespace js {

namespace jit {

class CacheIRCompiler;

namespace cachet {

using namespace ::cachet::prelude;

struct CachetContext {
  CacheIRCompiler* compiler;
  JSContext* js_ctx;
};

using Cachet_ContextRef = CachetContext;

inline void Cachet_Assert(bool cond) {
  MOZ_ASSERT(cond);
}

template <typename T>
struct GCType {
  using Val = T;
  using Local = js::Rooted<T>;
  using Ref = js::Handle<T>;
  using MutRef = js::MutableHandle<T>;

  static Val ToVal(const Local& local) {
    return local;
  }

  static Val ToVal(Ref ref) {
    return ref;
  }

  static Val ToVal(MutRef mutRef) {
    return mutRef;
  }

  static Local EmptyLocal(Cachet_ContextRef cx) {
    return Local(cx.js_ctx);
  }

  static Local ToLocal(Cachet_ContextRef cx, Val&& val) {
    return Local(cx.js_ctx, std::move(val));
  }

  static Local ToLocal(Cachet_ContextRef cx, Ref ref) {
    return Local(cx.js_ctx, ref);
  }

  static Local ToLocal(Cachet_ContextRef cx, MutRef mutRef) {
    return Local(cx.js_ctx, mutRef);
  }

  static Ref ToRef(const Local& local) {
    return local;
  }

  static Ref ToRef(MutRef mutRef) {
    return mutRef;
  }

  static MutRef ToMutRef(Local& local) {
    return &local;
  }

  static void SetMutRef(MutRef lhs, Val&& rhs) {
    lhs.set(std::move(rhs));
  }

  static void SetMutRef(MutRef lhs, const Local& rhs) {
    lhs.set(rhs);
  }

  static void SetMutRef(MutRef lhs, Ref rhs) {
    lhs.set(rhs);
  }

  static void SetMutRef(MutRef lhs, MutRef rhs) {
    lhs.set(rhs);
  }

  static bool Eq(Ref lhs, Ref rhs) {
    return lhs == rhs;
  }

  static bool Neq(Ref lhs, Ref rhs) {
    return lhs != rhs;
  }
};

using Type_Heap = Type_Unit;

using Type_ValueType = PrimitiveType<JS::ValueType>;
using Type_Value = GCType<JS::Value>;
using Type_Object = GCType<JSObject*>;
using Type_NativeObject = GCType<js::NativeObject*>;
using Type_Shape = GCType<js::Shape*>;
using Type_Class = PrimitiveType<const JSClass*>;

using Type_ValueReg = PrimitiveType<ValueOperand>;
using Type_Reg = PrimitiveType<Register>;
using Type_Condition = PrimitiveType<Assembler::Condition>;

using Type_ValueId = PrimitiveType<ValOperandId>;
using Type_ObjectId = PrimitiveType<ObjOperandId>;

using Type_Int32Field = PrimitiveType<uint32_t>;
using Type_ShapeField = PrimitiveType<uint32_t>;

inline Type_Heap::MutRef Var_heap(Cachet_ContextRef cx) {
  static Type_Heap::Local heap;
  return heap;
}

namespace IR_MASM {
  using LabelRef = Label*;
  using OpsRef = MacroAssembler&;
}



#define CACHET_CacheIR_COMPILER
#define CACHET_MASM_EMIT

#include "jit/CachetGenerated.h"

#undef CACHET_CacheIR_COMPILER
#undef CACHET_MASM_EMIT


// --------------------------------------------------
// Below this line, are accessors which are not
// generated by Cachet, but are used by CacheIRCompiler
// ----------------------------------------------------
//

namespace IR_CacheIR {

IR_MASM::OpsRef GetOutput(Cachet_ContextRef cx);

};  // namespace IR_CacheIR

namespace Impl_CacheIR {

Type_ValueReg::Ref Var_outputReg(Cachet_ContextRef cx);

};  // namespace Impl_CacheIR

};  // namespace cachet

};  // namespace jit

};  // namespace js

#endif /* jit_CachetCompiler_h */
