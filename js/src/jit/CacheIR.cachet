// vim: set tw=99 ts=4 sts=4 sw=4 et:

struct Heap;
var mut heap: Heap;

var zero: Int32;

enum ValueType {
  Double,
  Int32,
  Bool,
  Undefined,
  Null,
  Magic,
  String,
  Symbol,
  PrivateGCThing,
  BigInt,
  Object,
}

struct Value;

impl Value {
    fn typeOf(value: Value) -> ValueType;

    // ...

    fn isInt32(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Int32
    }

    fn isObject(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Object
    }

    fn isNull(value: Value) -> Bool {
        Value::typeOf(value) == ValueType::Null
    }

    fn fromInt32(int32: Int32) -> Value {
        let value = unsafe { Value::fromInt32Unchecked(int32) };
        assume Value::isInt32(value);
        assume unsafe { Value::toInt32Unchecked(value) } == int32;
        value
    }

    unsafe fn fromInt32Unchecked(value: Int32) -> Value;

    fn toInt32(value: Value) -> Int32 {
        assert Value::isInt32(value);
        let int32 = unsafe { Value::toInt32Unchecked(value) };
        assume unsafe { Value::fromInt32Unchecked(int32) } == value;
        int32
    }

    unsafe fn toInt32Unchecked(value: Value) -> Int32;

    fn fromObject(object: Object) -> Value {
        let value = unsafe { Value::fromObjectUnchecked(object) };
        assume Value::isObject(value);
        assume unsafe { Value::toObjectUnchecked(value) } == object;
        value
    }

    unsafe fn fromObjectUnchecked(value: Object) -> Value;

    fn toObject(value: Value) -> Object {
        assert Value::isObject(value);
        let object = unsafe { Value::toObjectUnchecked(value) };
        assume unsafe { Value::fromObjectUnchecked(object) } == value;
        object
    }

    unsafe fn toObjectUnchecked(value: Value) -> Object;
}

struct Object;

impl Object {
    // #[reads(heap)]
    // fn shapeOf(object: Object) -> Shape;
    fn shapeOf(object: Object) -> Shape {
        unsafe { Object::shapeOfUnchecked(heap, object) }
    }

    unsafe fn shapeOfUnchecked(heap: Heap, object: Object) -> Shape;

    fn toNativeObject(object: Object) -> NativeObject {
        let shape = Object::shapeOf(object);
        let class = Shape::classOf(shape);
        assert Class::isNativeObject(class);
        unsafe { object as NativeObject }
    }
  
    fn getFixedSlot(object: Object, slot: Int32) -> Value {
        let nativeObject = Object::toNativeObject(object);
        NativeObject::getFixedSlot(nativeObject, slot)
    }
}

struct NativeObject <: Object;

impl NativeObject {
    fn getFixedSlot(nativeObject: NativeObject, slot: Int32) -> Value {
        let shape = Object::shapeOf(nativeObject);
        assert Shape::hasFixedSlot(shape, slot);
        unsafe { NativeObject::getFixedSlotUnchecked(heap, nativeObject, slot) }
    }

    // #[reads(heap)]
    // unsafe fn getFixedSlotUnchecked(nativeObject: NativeObject, slot: Int32) -> Value;
    unsafe fn getFixedSlotUnchecked(heap: Heap, nativeObject: NativeObject, slot: Int32) -> Value;
}

struct Shape;

impl Shape {
    fn classOf(shape: Shape) -> Class;

    fn hasFixedSlot(shape: Shape, slot: Int32) -> Bool;
}

struct Class;

impl Class {
    fn isNativeObject(class: Class) -> Bool;
}

struct Reg;

// #[cfg(cpp)]
struct ValueReg;
// #[cfg(verify)]
// type ValueReg = Reg;

enum Condition {
    Equal,
    NotEqual,
}

ir MASM {
    op BranchTestObject(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsObject = Value::isObject(value);

        if condition == Condition::Equal {
            if valueIsObject {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsObject {
                goto branch;
            }
        }
    }

    op BranchTestNull(condition: Condition, valueReg: ValueReg, label branch: MASM) {
        let value = MASM::getValue(valueReg);
        let valueIsNull = Value::isNull(value);

        if condition == Condition::Equal {
            if valueIsNull {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !valueIsNull {
                goto branch;
            }
        }
    }

    op UnboxObject(valueReg: ValueReg, objectReg: Reg) {
        let value = MASM::getValue(valueReg);
        MASM::setObject(objectReg, Value::toObject(value));
    }

    op BranchTestObjectShape(
        condition: Condition, objectReg: Reg, shape: Shape, scratchReg: Reg, spectreRegToZero: Reg,
        label branch: MASM
    ) {
        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        MASM::setInt32(scratchReg, zero);

        if condition == Condition::Equal {
            if objectHasShape {
                MASM::setInt32(spectreRegToZero, MASM::getInt32(scratchReg));
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !objectHasShape {
                MASM::setInt32(spectreRegToZero, MASM::getInt32(scratchReg));
                goto branch;
            }
        }
    }

    op BranchTestObjectShapeNoSpectreMitigations(
        condition: Condition, objectReg: Reg, shape: Shape, label branch: MASM
    ) {
        let object = MASM::getObject(objectReg);
        let objectHasShape = Object::shapeOf(object) == shape;

        if condition == Condition::Equal {
            if objectHasShape {
                goto branch;
            }
        }

        if condition == Condition::NotEqual {
            if !objectHasShape {
                goto branch;
            }
        }
    }

    op LoadObjectFixedSlot(objectReg: Reg, slot: Int32, outputReg: ValueReg) {
        let object = MASM::getObject(objectReg);
        MASM::setValue(outputReg, Object::getFixedSlot(object, slot));
    }

    fn getValue(valueReg: ValueReg) -> Value;
    fn setValue(valueReg: ValueReg, value: Value);

    fn getInt32(reg: Reg) -> Int32;
    fn setInt32(reg: Reg, int32: Int32);

    fn getObject(reg: Reg) -> Object;
    fn setObject(reg: Reg, object: Object);
}

//#[cfg(cpp)]
//impl MASM {
    //fn getValue(valueReg: ValueReg) -> Value;
    //fn setValue(valueReg: ValueReg, value: Value);

    //fn getInt32(reg: Reg) -> Int32;
    //fn setInt32(reg: Reg, int32: Int32);

    //fn getObject(reg: Reg) -> Object;
    //fn setObject(reg: Reg, object: Object);
//}

//#[cfg(verify)]
//impl MASM {
    //var mut regs: Map<Reg, Value>;

    //fn getValue(valueReg: ValueReg) -> Value {
        //Map::get(MASM::regs, valueReg)
    //}

    //fn setValue(valueReg: ValueReg, value: Value) {
        //MASM::regs = Map::set(MASM::regs, valueReg, value);
    //}

    //fn getInt32(reg: Reg) -> Int32 {
        //Value::toInt32(MASM::getValue(reg))
    //}

    //fn setInt32(reg: Reg, int32: Int32) {
        //MASM::setValue(reg, Value::fromInt32(int32));
    //}

    //fn getObject(reg: Reg) -> Object {
        //Value::toObject(MASM::getValue(reg))
    //}

    //fn setObject(reg: Reg, object: Object) {
        //MASM::setValue(reg, Value::fromObject(object));
    //}
//}

struct ValueId;
struct ObjectId;

struct Int32Field;
struct ShapeField;

ir CacheIR emits MASM {
    op GuardIsNull(valueId: ValueId, label failure: MASM){
        let valueReg = CacheIR::useValueReg(valueId);
        emit MASM::BranchTestNull(Condition::NotEqual, valueReg, failure);
    }

    op GuardToObject(valueId: ValueId, objectId: ObjectId, label failure: MASM) {
        let valueReg = CacheIR::useValueReg(valueId);
        let objectReg = CacheIR::useObjectReg(objectId);
        emit MASM::BranchTestObject(Condition::NotEqual, valueReg, failure);
        emit MASM::UnboxObject(valueReg, objectReg);
    }











    // CACHET
    op GuardShape(objectId: ObjectId, shapeField: ShapeField, label failure: MASM) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let shape = CacheIR::readShapeField(shapeField);

        let needsSpectreMitigations = CacheIR::objectGuardNeedsSpectreMitigations(objectId);

        if needsSpectreMitigations {
            let scratchReg = CacheIR::allocateReg();
            emit MASM::BranchTestObjectShape(
                Condition::NotEqual, objectReg, shape, scratchReg, objectReg, failure
            );
            CacheIR::releaseReg(scratchReg);
        } else {
            emit MASM::BranchTestObjectShapeNoSpectreMitigations(
                Condition::NotEqual, objectReg, shape, failure
            );
        }
    }

























    op LoadFixedSlotResult(objectId: ObjectId, slotField: Int32Field) {
        let objectReg = CacheIR::useObjectReg(objectId);
        let slot = CacheIR::readInt32Field(slotField);
        emit MASM::LoadObjectFixedSlot(objectReg, slot, CacheIR::outputReg);
    }

    fn allocateReg() -> Reg;
    fn releaseReg(reg: Reg);

    fn allocateValueReg() -> ValueReg;
    fn releaseValueReg(valueReg: ValueReg);

    fn useValueReg(valueId: ValueId) -> ValueReg;
    fn useObjectReg(objectId: ObjectId) -> Reg;

    var outputReg: ValueReg;

    fn readInt32Field(int32Field: Int32Field) -> Int32;
    fn readShapeField(shapeField: ShapeField) -> Shape;

    fn objectGuardNeedsSpectreMitigations(objectId: ObjectId) -> Bool;
}

//#[cfg(cpp)]
//impl CacheIR {
    //fn allocateReg() -> Reg;
    //fn releaseReg(reg: Reg);

    //fn allocateValueReg() -> ValueReg;
    //fn releaseValueReg(valueReg: ValueReg);
//}

//#[cfg(verify)]
//impl CacheIR {
    //var mut allocatedRegs: Set<Reg>;

    //fn allocateReg() -> Reg {
        //let reg = unsafe { CacheIR::allocateRegUnchecked(CacheIR::allocatedRegs) };
        //assume !Set::contains(CacheIR::allocatedRegs, reg);
        //CacheIR::allocatedRegs = Set::add(CacheIR::allocatedRegs, reg);
        //reg
    //}

    //unsafe fn allocateRegUnchecked(allocatedRegs: Set<Reg>) -> Reg;

    //fn releaseReg(reg: Reg) {
        //CacheIR::allocatedRegs = Set::remove(CacheIR::allocatedRegs, reg);
    //}

    //fn allocateValueReg() -> ValueReg {
        //CacheIR::allocateReg()
    //}

    //fn releaseValueReg(valueReg: ValueReg) {
        //CacheIR::releaseReg(valueReg);
    //}
//}























ir CacheStub emits CacheIR {
    op GetProp(
        valueId: ValueId,
        objectId: ObjectId,
        shapeField: ShapeField,
        slotField: Int32Field,
        label failure: MASM
    ) {
        assume CacheIR::useValueReg(valueId) == CacheIR::allocateValueReg();
        assume CacheIR::useObjectReg(objectId) == CacheIR::allocateReg();

        let shape = CacheIR::readShapeField(shapeField);

        assume Class::isNativeObject(Shape::classOf(shape));

        assume Shape::hasFixedSlot(shape, 0);
        assume Shape::hasFixedSlot(shape, 1);
        assume Shape::hasFixedSlot(shape, 2);

        let slot = CacheIR::readInt32Field(slotField);
        assume slot == 1;

        emit CacheIR::GuardToObject(valueId, objectId, failure);
        emit CacheIR::GuardShape(objectId, shapeField, failure);
        emit CacheIR::LoadFixedSlotResult(objectId, slotField);
    }
}
